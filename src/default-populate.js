
const request = require('request-promise-native');
const JSZip = require("jszip");
const fs = require('fs-extra');
const path = require('path');

// let expectedBuildTypes = [
//   'types.second.default.app',
//   'types.second.default.code.js',
//   'types.second.default.service.js',
//   'types.second.default.permissions',
//   'types.second.default.route'
// ];


async function populate(){

  let VOLUME = process.env.ATTACHED_VOLUME_ROOT + 'root/';

  let url = process.env.LAUNCH_NODES_ZIP_URL;
  if(!url){
    console.error('Missing url!');
    return false;
  }

  // cannot simply follow github zipball/tarball links :( 
  console.log('URL:', url);
  // url = `https://cors-anywhere.herokuapp.com/${url}`;
  // console.log('URL2:', url);
  let zipResponse = await request({
    url,
    method: 'GET',
    encoding: null
  });
  // let zipBuffer = await zipResponse.arrayBuffer();
  console.log('downloaded zip file');
  let unzipped = await JSZip.loadAsync(zipResponse);

    
  console.log('loaded zip data!'); //, unzipped);

  // ZIP is valid! 
  let files = unzipped.files;

  function readFilePath(p){
    return new Promise(async (resolve,reject)=>{
      // console.log('path:', p);
      let r = await files[p].async('text')
      resolve(r);
    });
  }
  function readFilePathToBuffer(p){
    return new Promise(async (resolve,reject)=>{
      // console.log('path:', p);
      let r = await files[p].async('nodebuffer')
      resolve(r);
    });
  }

  // load all the nodes/files 
  let allFiles = {};
  let nodes = {};
  for(let filepath of Object.keys(files)){
    let file = files[filepath];
    // check if under '/nodes' 
    // console.log('filepath:', filepath);
    // console.log('contents:', contents);
    let normalizedPath = filepath.split('/').splice(1).join('/');
    let nodesSlashIdx = filepath.indexOf('nodes/');
    if(nodesSlashIdx > -1){
      let nameNoPrefix = filepath.slice(nodesSlashIdx + 'nodes/'.length);
      if(nameNoPrefix.split('/').length > 1){
        // file is deeper!
        if(file.dir){
          // skip directory names (nothing to save)
          console.log('writeDir:', nameNoPrefix);

          // ensure directory exists  
          await fs.ensureDir(path.join(VOLUME, nameNoPrefix));

        } else {
          let fdir = path.dirname( nameNoPrefix );

          // file 
          console.log('isFile:', nameNoPrefix, 'Dir:', fdir);

          // ensure directory, write file using Buffer 
          await fs.ensureDir(path.join(VOLUME, fdir));
          let fileData = await readFilePathToBuffer(filepath);
          await fs.writeFile(path.join(VOLUME, nameNoPrefix), fileData);
        }
      } else {
        if(!file.dir){
          // node
          let nodeName = nameNoPrefix.substring(0, nameNoPrefix.length - 5); // remove ".json" suffix 
          // // TODO: duplicates? 
          let contents = await readFilePath(filepath);
          contents = JSON.parse(contents);
          await App.secondAI.MySecond.putNodeAtPath(nodeName, contents) 
          console.log('writeNode:', nodeName);
        }
      }
    }
  }

  // console.log('Build services that are specified ');
  // console.log('Paths to build:', toBuild);

  // // expecting "services.second.default.bin.build" to exist, and NOT be code 

  // for(let nodeInfo of toBuild){
  //   // run code in vm for each: "services.second.default.bin.build" 
  //   // - build ALL, using defaults for each 
  //   let nodePath = nodeInfo[0];
  //   let node = nodeInfo[1];
  //   node.name = nodePath; // already done 


  // }

  // console.log('DONE3');
  // return false;

  // console.log('allFiles from Zip:'); //, allFiles);
  // console.log('nodes from zip:', JSON.stringify(Object.keys(nodes),null,2));
  
  // for(let name of Object.keys(nodes)){
  //   let nodeTypeData = nodes[name];
  //   console.log('saving node:', name, nodeTypeData.type);
  //   await App.secondAI.MySecond.putNodeAtPath(name, nodeTypeData) 
  // }
  
  console.log('Done Adding via Zip');



  // db:
  // - .put => "putNodeAtPath

  // fetch process.env.LAUNCH_BASE_URL (git url) 
  // - load /nodes into database 

  // await App.secondAI.MySecond.putNodeAtPath('services.second.default.get',{
  //   type: 'types.second.default.service.js',
  //   data: {
  //     "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n    \n      console.log('--Service:', SELF._path, '--');\n      \n      // PATH variable is the path we're executing against! \n      // - permissions already should have handled the \"pre\"\n      // - after fetching data, run the \"post\" checkPermissions event  \n      \n      console.log('PATH to get node:', PATH);\n      // console.log('AppNamedPaths:');\n      // console.log(JSON.stringify(Object.keys(universe.AppNamedPaths),null,2));\n      \n      // TODO: handle a missing node? \n      // - return null? \n      let result = await universe.getNodeAtPath(PATH);\n      \n      let returnResult;\n      let nodeResult;\n      \n      if(result){\n        returnResult = {\n          type: 'types.second.default.node.internal',\n          data: universe.lodash.pick(result,[\n            '_id',\n            '_path',\n            'name',\n            'type',\n            'data',\n            'createdAt',\n            'updatedAt'\n          ])\n        }\n      } else {\n        returnResult = {\n          type: 'types.second.default.null',\n          data: null\n        }\n      }\n      \n      return resolve(returnResult);\n        \n    }catch(err){\n      console.error('Error:', SELF._path, err);\n      resolve({\n        type: 'types.second.default.error',\n        data: {\n          message: err.toString()\n        }\n      });\n    }\n    \n    \n  })\n})()"
  //   }
  // }) 

  // await App.secondAI.MySecond.putNodeAtPath('services.second.default.put',{
  //   type: 'types.second.default.service.js',
  //   data: {
  //     "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      console.log('--service:', SELF._path, '--', PATH, AUTH);\n      \n      // console.log('INPUT:', INPUT); \n      \n  \t\tlet node = {\n  \t\t  type: INPUT.type,\n  \t\t  data: INPUT.data,\n  \t\t}\n      \n      let opts = {};\n      let key;\n        \n      // console.log('putNodeAtPath', PATH, node);\n      let result;\n      try {\n        result = await universe.putNodeAtPath(PATH, key, node, opts);\n      }catch(err){\n        // determine why failure \n        console.error('Failed putNodeAtPath:', err);\n        return resolve({\n          type: 'types.second.default.error',\n          data: {\n            message: 'Failed putNodeAtPath',\n            error: err\n          }\n        });\n      }\n      // let result = node;\n      \n      console.log('Result of saving putNodeAtPath (new node w/ _id)', result);\n      \n      let returnResult;\n      \n      if(result){\n        // success \n        returnResult = {\n          type: 'types.second.default.boolean',\n          data: true\n        }\n      } else {\n        // failure \n        returnResult = {\n          type: 'types.second.default.null',\n          data: null\n        }\n      }\n      \n      return resolve(returnResult);\n        \n        \n    }catch(err){\n      console.error('Error:', SELF._path, err);\n      resolve({\n        type: 'types.second.default.error',\n        data: {\n          message: err.toString()\n        }\n      });\n    }\n    \n    \n  })\n})()"
  //   }
  // }) 

  // await App.secondAI.MySecond.putNodeAtPath('services.second.default.get_for_pattern',{
  //   type: 'types.second.default.service.js',
  //   data: {
  //     "code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n    \n      console.log('--service:', SELF.name, '--', PATH, AUTH);\n      \n      // console.log('INPUT:', INPUT); \n      \n      // PATH variable is the path we're executing against! \n      // - permissions already should have handled the \"pre\"\n      // - after fetching data, run the \"post\" checkPermissions event  \n      \n      // INPUT.type == types.second.default.array_of_string_patterns\n      // INPUT.data == string or [array_of_patterns]\n      \n      // TODO: handle a missing node? \n      // - return null? \n      let result = await universe.getNodesForPathPattern(INPUT.data);\n      \n      let returnResult;\n      let nodeResult;\n      \n      if(result){\n        returnResult = {\n          type: 'types.second.default.node.internal',\n          data: universe.lodash.pick(result,[\n            '_id',\n            '_path',\n            'name',\n            'type',\n            'data',\n            'createdAt',\n            'updatedAt'\n          ])\n        }\n      } else {\n        returnResult = {\n          type: 'types.second.default.null',\n          data: null\n        }\n      }\n      \n      return resolve(returnResult);\n        \n    }catch(err){\n      console.error('Error:', SELF._path, err);\n      resolve({\n        type: 'types.second.default.error',\n        data: {\n          message: err.toString()\n        }\n      });\n    }\n    \n    \n  })\n})()"}
  // }) 

  // await App.secondAI.MySecond.putNodeAtPath('services.second.default.input.from_http',{
  //   type: 'types.second.default.service.js',
  //   data: {"code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n  \n      console.log('Incoming Route Request. INPUT.type:', INPUT.type);\n      \n      // Expecting an Expressjs object for input \n      // - types.second.default.request.http_express_obj\n      \n      // request via HTTP post method (expressjs server expected) \n      // - headers and body are included\n      //   - body is JSON (expected to be!) \n      \n      // console.log('incoming_web_request!!');\n      // return resolve({\n      //   ok: true\n      // });\n          \n      \n      let expressNode, headers, body, urlPath;\n      \n      switch(INPUT.type){\n        \n        case 'types.second.default.request.http_express_obj':\n          // Express HTTP Request (default) \n          \n          expressNode = INPUT; \n          \n          headers = expressNode.data.req.headers;\n          body = expressNode.data.req.body;\n          urlPath = expressNode.data.req.path;\n          \n          break;\n          \n          \n        default:\n          console.error('Failed INPUT.type for from_http');\n          return resolve({\n            type: 'invalid_internal_type:Qmsdfisf',\n            data: false\n          });\n      }\n      \n      \n      // console.log('BODY:', JSON.stringify(body,null,2));\n      // console.log('ExpressNode:', universe.cJSON.stringify(expressNode,null,2));\n      \n      \n      // Load routes, controllers for each (TODO) \n      // - MVC-like for web requests, expecting most non-node requests to be authentication one-offs \n      \n      \n      // // cache the route-finding code \n      // let cacheAppId = universe.getParentRoot(SELF)._id;\n      // let cache = ['incoming_web_request_route_nodes', cacheAppId].join('|');\n      \n      // // app root-level (old: global-root) \n      // let routeNodes = await universe.searchMemory({\n      //   cache,\n      //   filter: {\n      //     sqlFilter: {\n      //       // nodeId: null // OLD: root-level\n      //       type: 'incoming_route_handler:Qmsdfkj329j3'\n      //     },\n      //     // function for returning data from the Node, after filtering a bit \n      //     // - includes both the Node, and Nodes with nodeId (pointers) \n      //     filterNodes: tmpNodes=>{\n      //       // this runs isolated, outside of the above context? (not sure..think it is same context though [using INPUT.data.type in search]) \n      //       return new Promise((resolve, reject)=>{\n      //         tmpNodes = tmpNodes.filter(tmpNode=>{\n      //           // see if has a ChildNode matching a type \n                \n      //           if(!universe.sameAppPlatform(SELF, tmpNode)){\n      //             // console.log('FOUND IT UNDER SAME APP!!!!!', tmpNode._id);\n      //             return false;\n      //           }\n                \n      //           return true;\n                \n      //         });\n      //         resolve(tmpNodes);\n      //       });\n      //     },\n      //   }\n      // });\n      \n      // console.log('Getting routeNodes');\n      \n      let routeNodes = await universe.getNodesForPathPattern('data.second.default.routes.*',{});\n      \n      console.log('routeNodes:', routeNodes.length);\n      // console.log('routeNodes length:', routeNodes.length);\n      \n      // console.log('Sort routes');\n      \n      // prevent \"/ai\" from being pushed to the bottom! \n      // - mucking with /ai will cause some serious problems! \n      \n      let routes = routeNodes.sort((a,b)=>{\n        try {\n            // multiple /ai's?\n          if((!a.data || !b.data) || (a.data.ai && !b.data.ai)){\n            return -1;\n          }\n          if(b.data.ai && !a.data.ai){\n            return 1;\n          }\n          return (a.data.priority > b.data.priority) ? 1:-1; // lower priority => checked first!\n        }catch(err){\n          console.error('err sorting routes:', err);\n          return 0;\n        }\n      }).map(routeNode=>{\n        // get codeNode to run \n        let routeTxtMatches = routeNode.data ? (routeNode.data.routes || []):[]; // multiple allowed \n        \n        let routeCodeNodeToRun = universe.lodash.find(routeNode.nodes,n=>{\n          return n.name.endsWith('.code');\n        });\n        \n        return [routeTxtMatches, routeCodeNodeToRun, routeNode];\n      });\n      \n      // console.log('Checking routes', routes.length);\n      \n      // // print out routes to check (order\n      // for(let route1 of routes){\n      //   console.log('ROUTECheck1:',JSON.stringify(route1[0]));\n      // }\n      \n      const RouteParser = universe.require('route-parser');\n      \n      let routed = false;\n      for(let route of routes){\n        if(routed){continue}\n        for(let tmpMatchRoute of route[0]){\n          if(routed){continue}\n          let tmpRoute = new RouteParser(tmpMatchRoute);\n          let match = tmpRoute.match(urlPath)\n          if(match){\n            routed = true;\n            \n            // console.log('MATCH ROUTE:', match ? true:false, tmpMatchRoute, match);\n            \n            // update expressNode with params\n            expressNode.data.params = match;\n            \n            // check authentication\n            // - as part of routeNode.data.auth (TODO: better auth/versioning/groups/etc) \n            let routeNode = route[2];\n            if(routeNode.data.auth){\n              // require loggedin? \n              // - all apps are internal-only? \n              // - TODO: per-app basis? \n              let {req,res} = expressNode.data;\n              if(req.session.loggedin){\n                if(routeNode.data.auth.loggedin !== true){\n                  // loggedin people NOT allowed (kinda wierd, TODO: use groups/etc to determine loggedin/user) \n                  res.redirect(`/auth/logout2?redirect=${encodeURIComponent(req.originalUrl)}`);\n                  return resolve(true);\n                }\n              } else {\n                // not logged in, anonymous must be allowed \n                if(routeNode.data.auth.anonymous !== true){\n                  // loggedin people NOT allowed (kinda wierd, TODO: use groups/etc to determine loggedin/user) \n                  res.redirect(`/auth/login?redirect=${encodeURIComponent(req.originalUrl)}`);\n                  return resolve(true);\n                }\n              }\n              \n            }\n            \n            // run in vm, and pass in the inputSchema Node! \n            // - of the action! (expecting/requiring it to be a Node w/ code....how to verify that? logic vs data?) \n            let routeResult;\n            try {\n              // console.log('Getting routeResult');\n              routeResult = await universe.execCodeNode({\n                codeNode: route[1], // includes type/schemaName and data \n                dataNode: expressNode, // passes express obj, with req, res \n                timeout: 15 * 1000\n              });\n            }catch(err){\n              return resolve('FAILED code from from_http, trying to run route');\n            }\n            \n            // console.log('executed route, expecting to have already responded using expressNode.data.res.send()');\n            return resolve({\n              type: 'executed_route:Qmmf3290jhgj',\n              data: true\n            });\n            \n          }\n        }\n      }\n      \n      if(!routed){\n        console.log('No Route Matches');\n        await universe.httpResponse('send','404 - Missing Page');\n        \n        return resolve({\n          type: 'missing_route:Qm404sfhsf',\n          data: false\n        });\n      }\n      \n      return resolve({\n        type: 'boolean:...',\n        data: true\n      });\n      \n      \n        \n        \n    }catch(err){\n      console.error('Failed route:', err);resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()","description":"Default handler for an http input"}
  // }) 


  // await App.secondAI.MySecond.putNodeAtPath('services.second.default.input',{
  //   type: 'types.second.default.service.js',
  //   data: {
  // "description": "Default handler for an input coming in",
  // "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      console.log('--service:', SELF._path, '--', PATH);\n      \n      // Basically running execService with the incoming authObj \n      // - convert incoming/external authObj (with a token) to an internal authObj (with permissions) \n      \n      // expecting INPUT \n      \n      let secondResponseNode;\n      let bodyNode = INPUT;\n      \n      // console.log('bodyNode', bodyNode);\n      \n      // bodyNode MUST be in a standard format that we can convert for execService w/ a valid auth obj \n      // - TODO: validate \n      if(bodyNode.type != 'types.second.default.request.input'){\n        console.error('Invalid bodyNode.type! Expecting \"types.second.default.request.input\" and received:', bodyNode.type);\n        return false;\n      }\n      \n      let {\n        auth,\n        serviceName,\n        actionPath,\n        inputNode,\n        extras // for auth_additions (dynamic additions for request, could be just about anything?) \n      } = bodyNode.data;\n      \n      // bodyNode = {\n      //   type: \"types.second.default.request.input\",\n      //   data: {\n      //     serviceName: 'services.second.default.get',\n      //     actionPath: 'data.second.default.blogposts.xyz',\n      //     inputNode: {\n      //       ...\n      //     },\n      //     auth: {\n      //       token: \n      //     }\n      //   }\n      // }\n      \n      \n      // convert incoming authObj w/ token\n      let token = auth ? auth.token:null;\n      if(!token){\n        console.log('Missing bodyNode.data.auth.token (anonymous)');\n        // return false;\n      }\n      \n      // validate token (no dots, etc.) \n      if(token){\n        token = token.split('.').join('');\n      }\n      \n      // convert token to permissions object \n      let authNode;\n      if(token){\n        authNode = await universe.getNodeAtPath(`tokens.auth.${token}`, {lean: true, fields: ['_path','type','data']});\n        if(!authNode){\n          console.error('Failed to find authNode/user for supplied token');\n        } else {\n          // Found matching authNode using token \n          // - get permission node too \n          let permissionsNode = await universe.getNodeAtPath(`tokens.auth.${token}.permissions`, {lean: true, fields: ['type','data']});\n          try {\n            authNode.permissions = permissionsNode.data.permissions;\n          }catch(err){\n            console.error('Missing permissions node for token:', token);\n          }\n        }\n      }\n      \n      if(!authNode){\n        // change to an anonymous user \n        // - TODO: respond with invalid/expired auth \n        console.log('Using an anonymous user');\n        authNode = {\n          type: 'builtin.auth',\n          data: {\n            isOwner: false\n          },\n          extras: {}, // for additional key-value entries, that can be used by the permissions (groups, etc?) \n          permissions: [], // should be a node w/ name=\"permissions\" in authObj.nodes[] (permissionsNode.data.permissions)\n          // nodes: [{\n          //   name: 'permissions',\n          //   type: 'types.second.default.permissions',\n          //   data: {\n          //     permissions: []\n          //   }\n          // }]\n        }\n      } else {\n        console.log('using supplied authNode!');\n      }\n      \n      \n    //   // checkPermissions using \"pre\" event \n  \t\t// let permissionResult = await funcInSandbox.universe.checkPermission({\n  \t\t// \teventName: 'pre', // 'std.second.permission_type.before_service_run',\n  \t\t// \tserviceName,\n  \t\t// \tactionPath,\n  \t\t// \tinputNode,\n  \t\t// \tauthNode\n  \t\t// });\n  \t\t// if(permissionResult === true){\n\n  \t\t// } else {\n    //     // not allowing\n    //     console.error('--Not allowed!!--');\n    //     return false;\n  \t\t// }\n  \t\t\n  \t\t// Service exists? \n  \t\tlet serviceNode = await universe.getNodeAtPath(serviceName);\n  \t\tif(!serviceNode){\n  \t\t\tsecondResponseNode = {\n  \t\t\t  type: 'types.second.default.response.error',\n  \t\t\t  data: {\n  \t\t\t    errorCode: 1,\n  \t\t\t    message: 'Invalid service name, unavailable'\n  \t\t\t  }\n  \t\t\t}\n        await universe.httpResponse('send', secondResponseNode);\n  \t\t  return resolve(secondResponseNode);\n  \t\t}\n  \t\t\n  \t\t\n  \t\t// run execService \n\t\t\tlet resultNode = await universe.execService(serviceName, {\n\t\t\t  actionPath,\n\t\t\t  inputNode,\n\t\t\t\tauthNode\n\t\t\t});\n\t\t\t\n\t\t\tconsole.log('Got secondResponseNode from execService in /ai!');\n\t\t\t\n\t\t\t// wrap output each time \n\t\t\tsecondResponseNode = {\n\t\t\t  type: 'types.second.default.response',\n\t\t\t  data: (resultNode === undefined) ? null:resultNode\n\t\t\t}\n      \n      return resolve(secondResponseNode);\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  // }
  // }) 



  // await App.secondAI.MySecond.putNodeAtPath('permissions',{
  //   type: 'types.second.default.permissions',
  //   data: {
  //     "description": "root permissions for doing anything on anything",
  //     "permissions": [
  //       {
  //         "services": [
  //           "services.**",
  //           "!services.second.default.auth"
  //         ],
  //         "events": [
  //           "pre"
  //         ],
  //         "code": "permission_codes.second.default.is_owner",
  //         "vars": {},
  //         "output": {
  //           "true": "allow"
  //         }
  //       }
  //     ]
  //   }
  // }) 

  // await App.secondAI.MySecond.putNodeAtPath('permissions.services.second.default',{
  //   type: 'types.second.default.permissions',
  //   data: {
  //     "description": "root permissions for doing anything on anything",
  //     "permissions": [
  //       {
  //         "services": [
  //           "services.**",
  //           "!services.second.default.auth"
  //         ],
  //         "events": [
  //           "pre"
  //         ],
  //         "code": "permission_codes.second.default.is_owner",
  //         "vars": {},
  //         "output": {
  //           "true": "allow"
  //         }
  //       }
  //     ]
  //   }
  // }) 


  // await App.secondAI.MySecond.putNodeAtPath('permission_codes.second.default.allow',{
  //   type: 'types.second.default.permissions',
  //   data: {
  //     "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // console.log('-- RUNNING PERMISSION CHECK --');\n      console.log('Running PermissionsCode', SELF._path);\n      \n      return resolve(true);\n      \n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  //   }
  // }) 
  // await App.secondAI.MySecond.putNodeAtPath('permission_codes.second.default.is_owner',{
  //   type: 'types.second.default.permissions',
  //   data: {
  //     "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // console.log('-- RUNNING PERMISSION CHECK --');\n      console.log('Running PermissionsCode', SELF._path);\n      \n      // INPUT contains similar information as for the execService call \n      // - AUTH, PATH, \n      // console.log('Permissions Check INPUT:', INPUT);\n      \n      // INPUT = {\n      //   eventName,\n      //   serviceName,\n      //   actionPath,\n      //   authNode\n      // }\n      \n      let { \n        authNode\n      } = INPUT;\n      \n      // console.log('authNode:', JSON.stringify(authNode,null,2));\n      \n      try {\n        if(authNode.permissions.owner){\n          return resolve(true);\n        }\n      }catch(err){}\n      \n      try {\n        if(authNode.data.permissions.owner){\n          return resolve(true);\n        }\n      }catch(err){}\n      \n      try {\n        // token.data.isOwner \n        if(authNode.data.isOwner){\n          return resolve(true);\n        }\n      }catch(err){}\n      \n      return resolve(false);\n      \n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  //   }
  // }) 
  // await App.secondAI.MySecond.putNodeAtPath('permission_codes.second.default.true',{
  //   type: 'types.second.default.permissions',
  //   data: {
  //     "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // console.log('-- RUNNING PERMISSION CHECK --');\n      console.log('Running PermissionsCode', SELF._path);\n      \n      return resolve(true);\n      \n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  //   }
  // }) 



  // await App.secondAI.MySecond.putNodeAtPath('data.second.default.routes.home',{
  //   type: 'types.second.default.route',
  //   data: {
  //     "priority": 5,
  //     "routes": [
  //       "/"
  //     ],
  // "auth":{
  //   "anonymous":true,
  //   "loggedin":true}
  //   }
  // }) 
  // await App.secondAI.MySecond.putNodeAtPath('data.second.default.routes.home.code',{
  //   type: 'types.second.default.code.js',
  //   data: {
  //     "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      console.log('--incoming_route_handler: Home--');\n    \n      let page = `\n        <!DOCTYPE html>\n        <html>\n          <head>\n            <meta charset=\"utf-8\">\n            <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n            <title>Home</title>\n          </head>\n          <body>\n            Home\n          </body>\n        </html>\n      `;\n\n      await universe.httpResponse('send', page);\n      \n      return resolve(true);\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  //   }
  // }) 


  // await App.secondAI.MySecond.putNodeAtPath('data.second.default.routes.ai',{
  //   type: 'types.second.default.route',
  //   data: {
  // "priority": 1,
  // "routes": [
  //   "/ai"
  // ],
  // "auth":{
  //   "anonymous":true,
  //   "loggedin":true}
  // }
  // }) 
  // await App.secondAI.MySecond.putNodeAtPath('data.second.default.routes.ai.code',{
  //   type: 'types.second.default.code.js',
  //   data: {
  // "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      console.log('--incoming_route_handler: /ai--');\n      \n      // Basically running execService with the incoming authObj \n      // - convert incoming/external authObj (with a token) to an internal authObj (with permissions) \n      \n      // expecting INPUT \n      \n      let inputNode = INPUT.data.req.body;\n      \n  \t\t// run execService \n\t\t\tlet resultNode = await universe.execService('services.second.default.input', {\n\t\t\t  actionPath: 'builtin.input',\n\t\t\t  inputNode,\n\t\t\t\tauthNode: {}, // TODO: use new node \n\t\t\t\tisOwner: true // overwrites authNode? \n\t\t\t});\n\t\t\t\n      await universe.httpResponse('send', resultNode);\n      \n      return resolve(true);\n        \n        \n    }catch(err){\n      console.error('Error:', SELF._path, err);\n      resolve({\n        type: 'types.second.default.error',\n        data: {\n          message: err.toString()\n        }\n      });\n    }\n    \n    \n  })\n})()"
  // }
  // }) 


  // await App.secondAI.MySecond.putNodeAtPath('data.second.default.routes.auth_grant',{
  //   type: 'types.second.default.route',
  //   data: {
  // "priority": 5,
  // "routes": [
  //   "/auth/grant",
  //   "/auth/grant/*any"
  // ],
  // "auth":{
  //   "anonymous":true,
  //   "loggedin":true}
  // }
  // }) 
  // await App.secondAI.MySecond.putNodeAtPath('data.second.default.routes.auth_grant.code',{
  //   type: 'types.second.default.code.js',
  //   data: {
  // "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      console.log('--incoming_route_handler: Auth Grant (for owner) --');\n      \n      let htmlNode, page;\n      \n      // get request session object (for finding if logged in using a cookie) \n      let {\n        req,\n        res \n      } = universe.requestsCache[universe.requestId];\n      \n      if(req.session.loggedin){\n        \n        if(req.method.toLowerCase() == 'post'){\n          // granting request \n          \n          // generate token \n          // - save data for token, so can be picked back up \n          let tokenNode = {\n            type: 'types.second.default.auth.token',\n            data: {\n              isOwner: true\n            },\n            // extras: {}, // for additional key-value entries, that can be used by the permissions (groups, etc?) \n            // permissions: [], // should be a node w/ name=\"permissions\" in authObj.nodes[]\n            // nodes: []\n          };\n          \n          // from the incoming grant request \n          // - TODO: use a package system for permissions (check approval, etc) \n          let permissionsNode = {\n            type: 'types.second.default.permissions',\n            data: {\n              permissions: [\n                // default: allow all \n                {\n                  \"services\": [\n                    \"services.**\"\n                  ],\n                  \"events\": [\n                    \"pre\",\n                  ],\n                  \"code\": \"permission_codes.second.default.true\",\n                  \"vars\": {},\n                  \"output\": {\n                    \"true\": \"allow\"\n                  }\n                }\n              ]\n            }\n          }\n          \n          let tokenId = universe.uuidv4();\n          \n          console.log('tokenId created:', tokenId);\n          \n          let tokenNodeSaved = await universe.putNodeAtPath(`tokens.auth.${tokenId}`,tokenNode, {});\n          console.log(`Created token: tokens.auth.${tokenId}`);\n          let permissionsNodeSaved = await universe.putNodeAtPath(`tokens.auth.${tokenId}.permissions`, permissionsNode, {});\n          console.log(`Created Permissions: tokens.auth.${tokenId}.permissions`);\n          \n          console.log('Granted!');\n          \n          let redirect = req.query.redirect;\n          \n          res.redirect(redirect + '#&token=' + tokenId);\n          \n          return resolve(true);\n          \n        } else {\n          // show the \"grant\" page \n          htmlNode = await universe.getNodeAtPath('data.second.default.routes.auth_grant.grant_html');\n          page = htmlNode.data.html;\n        }\n        \n      } else {\n        \n        // htmlNode = await universe.getNodeAtPath('data.second.default.routes.auth_grant.login_html');\n        // page = htmlNode.data.html;\n        \n        res.redirect(`/auth/login?redirect=${encodeURIComponent(req.originalUrl)}`);\n        return resolve(true);\n        \n      }\n\n      res.send(page);\n      \n      return resolve(true);\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  // }
  // }) 
  // await App.secondAI.MySecond.putNodeAtPath('data.second.default.routes.auth_grant.grant_html',{
  //   type: 'types.second.default.code.html',
  //   data: {
  // "html": "<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    <title>Auth Grant</title>\n    <script src=\"https://unpkg.com/react@16/umd/react.development.js\"></script>\n    <script src=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\"></script>\n    \n    <!-- Don't use this in production: -->\n    <script src=\"https://unpkg.com/babel-standalone@6.15.0/babel.min.js\"></script>\n    \n    <style>\n      .nodisplay {\n        display: none;\n      }\n    </style>\n    \n  </head>\n  <body>\n    <div id=\"root\"></div>\n    <script type=\"text/babel\">\n      \n      // require a login page (stored in session/cookie) \n      // if logged in, show the button to grant a new token \n      \n      \n      class App extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {}\n        }\n        render() { \n          return (\n            <div>\n              <h1>Grant Permissions</h1>\n              <Main />\n            </div>\n          ); \n        } \n      }\n      \n      class Main extends React.Component {\n        constructor(props){\n          super(props);\n          \n          let urlParams = new URLSearchParams(window.location.search);\n          let redirectTo = urlParams.get('redirect');\n          \n          this.state = {\n            redirectTo\n          }\n        }\n        handleRedirect = ()=>{\n          // NOT USED\n          // - form is POST'd to server \n          return false;\n          \n          console.log('Redirect!');\n          let urlParams = new URLSearchParams(window.location.search);\n          let redirectTo = urlParams.get('redirect');\n          \n          console.log('redirectTo:', redirectTo);\n          \n          redirectTo = redirectTo + '#token=xyz123';\n          \n          window.location = redirectTo;\n\n        }\n        render(){\n          return (\n            <form method=\"post\" action={\"/auth/grant?redirect=\" + this.state.redirectTo}>\n              <input type=\"submit\" value=\"Grant and Redirect Back\" />\n              {/*<button onClick={this.handleRedirect}>Grant and Redirect Back</button>*/}\n            </form>\n          )\n        }\n        \n      }\n      \n      \n      \n      ReactDOM.render(\n        <App />,\n        document.getElementById('root')\n      );\n\n    </script>\n    \n    \n  </body>\n</html>"
  // }
  // }) 
  // await App.secondAI.MySecond.putNodeAtPath('data.second.default.routes.auth_grant.login_html',{
  //   type: 'types.second.default.code.html',
  //   data: {
  // "html": "<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    <title>Second Login</title>\n    <script src=\"https://unpkg.com/react@16/umd/react.development.js\"></script>\n    <script src=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\"></script>\n    \n    <!-- Don't use this in production: -->\n    <script src=\"https://unpkg.com/babel-standalone@6.15.0/babel.min.js\"></script>\n    \n    <style>\n      .nodisplay {\n        display: none;\n      }\n    </style>\n    \n  </head>\n  <body>\n    <div id=\"root\"></div>\n    <script type=\"text/babel\">\n      \n      // require a login page (stored in session/cookie) \n      // if logged in, show the button to grant a new token \n      \n      // post login to session, reload page \n      \n      class App extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {}\n        }\n        render() { \n          return (\n            <div>\n              <h1>Login</h1>\n              <Login />\n            </div>\n          ); \n        } \n      }\n      \n      class Login extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {\n            passphrase: ''\n          }\n        }\n        handleSubmit = async ()=>{\n          console.log('Trying login using passphrase');\n          \n          let { passphrase } = this.state;\n          \n          const rawResponse = await fetch('/auth/login', {\n            method: 'POST',\n            headers: {\n              'Accept': 'application/json',\n              'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({passphrase})\n          });\n          const content = await rawResponse.json();\n  \n          console.log('Login response:', content);\n          if(content){\n            window.location.reload();\n          } else {\n            console.log('Not logged in');\n            window.alert('Invalid passphrase');\n          }\n          \n          return false;\n        }\n        render(){\n          return (\n            <div>\n              <input \n                type=\"text\" \n                placeholder=\"passphrase\"\n                onChange={e=>this.setState({passphrase:e.target.value})}\n                value={this.state.passphrase}\n              />\n              <button onClick={this.handleSubmit}>\n                Login\n              </button>\n            </div>\n          )\n        }\n        \n      }\n      \n      \n      ReactDOM.render(\n        <App />,\n        document.getElementById('root')\n      );\n\n    </script>\n    \n    \n  </body>\n</html>"
  // }
  // }) 
  // await App.secondAI.MySecond.putNodeAtPath('data.second.default.routes.auth_login',{
  //   type: 'types.second.default.route',
  //   data: {
  // "priority": 1,
  // "routes": [
  //   "/auth/login"
  // ],
  // "auth":{
  //   "anonymous":true,
  //   "loggedin":true}
  // }
  // }) 
  // await App.secondAI.MySecond.putNodeAtPath('data.second.default.routes.auth_login.code',{
  //   type: 'types.second.default.code.js',
  //   data: {"code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      console.log('--incoming_route_handler: /auth/login --');\n      \n      // processes login submission \n      // - expecting ajax response \n      \n      let {\n        req,\n        res\n      } = universe.requestsCache[universe.requestId];\n      \n      let redirectTo = req.query.redirect;\n      \n      function respond(){\n        if(redirectTo){\n          res.redirect(redirectTo);\n          return;\n        }\n        return res.send(true);\n      }\n      \n      console.log('redirectTo:', redirectTo);\n      \n      // already logged in? \n      if(req.session.loggedin){\n        return respond();\n      }\n      \n      let htmlNode = await universe.getNodeAtPath(universe.navPathv1(SELF.name, 1, 'login_html'));\n      \n      if(req.method.toLowerCase() != 'post'){\n        // login html \n        res.send(htmlNode.data.html);\n        return resolve(true);\n      }\n      \n      let ownerLoginNode = await universe.getNodeAtPath('private.auth.owner');\n      // let ownerUserNode = await universe.getNodeAtPath('idenities.owner');\n      \n      // check password, todo: bcrypted \n      if(ownerLoginNode.data.passphrase != req.body.passphrase){\n        // failed, resend the login html \n        // - TODO: different? \n        console.error('invalid password');\n        if(redirectTo){\n          res.send(htmlNode.data.html);\n        } else {\n          res.send(false);\n        }\n        return resolve(false);\n      }\n      \n      // set session value \n      // - expecting /auth/grant next \n      req.session.loggedin = true;\n      respond();\n      \n      return resolve(true);\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"}
  // }) 
  // await App.secondAI.MySecond.putNodeAtPath('data.second.default.routes.auth_login.login_html',{
  //   type: 'types.second.default.code.html',
  //   data: {
  // "html": "<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    <title>Second Login</title>\n    <script src=\"https://unpkg.com/react@16/umd/react.development.js\"></script>\n    <script src=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\"></script>\n    \n    <!-- Don't use this in production: -->\n    <script src=\"https://unpkg.com/babel-standalone@6.15.0/babel.min.js\"></script>\n    \n    <style>\n      .nodisplay {\n        display: none;\n      }\n    </style>\n    \n  </head>\n  <body>\n    <div id=\"root\"></div>\n    <script type=\"text/babel\">\n      \n      // require a login page (stored in session/cookie) \n      // if logged in, show the button to grant a new token \n      \n      // post login to session, reload page \n      \n      class App extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {}\n        }\n        render() { \n          return (\n            <div>\n              <h1>Login</h1>\n              <Login />\n            </div>\n          ); \n        } \n      }\n      \n      class Login extends React.Component {\n        constructor(props){\n          super(props);\n          \n          let urlParams = new URLSearchParams(window.location.search);\n          let redirectTo = urlParams.get('redirect');\n          \n          console.log('redirect to:', redirectTo);\n          \n          this.state = {\n            redirectTo,\n            passphrase: ''\n          }\n        }\n        handleSubmit = async ()=>{\n          console.log('Trying login using passphrase');\n          \n          let { passphrase } = this.state;\n          \n          const rawResponse = await fetch('/auth/login', {\n            method: 'POST',\n            headers: {\n              'Accept': 'application/json',\n              'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({passphrase})\n          });\n          const content = await rawResponse.json();\n  \n          console.log('Login response:', content);\n          if(content){\n            window.location = this.state.redirectTo;\n          } else {\n            console.log('Not logged in');\n            window.alert('Invalid passphrase');\n          }\n          \n          return false;\n        }\n        render(){\n          return (\n            <div>\n              <input \n                type=\"text\" \n                placeholder=\"passphrase\"\n                onChange={e=>this.setState({passphrase:e.target.value})}\n                value={this.state.passphrase}\n              />\n              <button onClick={this.handleSubmit}>\n                Login\n              </button>\n            </div>\n          )\n        }\n        \n      }\n      \n      \n      ReactDOM.render(\n        <App />,\n        document.getElementById('root')\n      );\n\n    </script>\n    \n    \n  </body>\n</html>"
  // }
  // }) 
  // await App.secondAI.MySecond.putNodeAtPath('data.second.default.routes.auth_logout',{
  //   type: 'types.second.default.route',
  //   data: {
  // "priority": 1,
  // "routes": [
  //   "/logout",
  //   "/auth/logout"
  // ],
  // "auth":{
  //   "anonymous":true,
  //   "loggedin":true}
  // }
  // }) 
  // await App.secondAI.MySecond.putNodeAtPath('data.second.default.routes.auth_logout.code',{
  //   type: 'types.second.default.code.js',
  //   data: {
  // "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      console.log('--incoming_route_handler: /auth/logout --');\n      \n      // processes login submission \n      // - expecting ajax response \n      \n      let {\n        req,\n        res\n      } = universe.requestsCache[universe.requestId];\n      \n      req.session.loggedin = false;\n      \n      res.send(true);\n      return resolve(true);\n        \n    }catch(err){\n      console.error('Error:', SELF._path, err);\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  // }
  // }) 

  // await App.secondAI.MySecond.putNodeAtPath('data.second.default.routes.api_get_for_pattern',{
  //   type: 'types.second.default.route',
  //   data: {
  // "priority": 1,
  // "routes": [
  //   "/api/get_for_pattern"
  // ],
  // "auth":{
  //   "loggedin":true}
  // }
  // }) 
  // await App.secondAI.MySecond.putNodeAtPath('data.second.default.routes.api_get_for_pattern.code',{
  //   type: 'types.second.default.code.js',
  //   data: {"code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      console.log('--incoming_route_handler: /api/get-nodes-for-paths --');\n      \n      // This is just temporary! \n      \n      let bodyNode = INPUT.data.req.body;\n      \n      console.log('bodyNode:', bodyNode);\n      \n  \t\t// expecting an _id! \n  \t\t\n  \t\tif(!bodyNode.paths){\n  \t\t  console.error('Missing array of paths');\n        await universe.httpResponse('send', false);\n  \t\t  return false;\n  \t\t}\n  \t\t\n  \t\t// array of paths is expected\n  \t\t// - i.e. [\"data.second.default.routes.*\"]\n  \t\t\n      let nodes = await universe.getNodesForPathPattern(bodyNode.paths,{});\n      \n      let returnNodes = [];\n      \n      // exclude data? \n      if(!bodyNode.excludeData){\n        returnNodes = nodes;\n      } else {\n          \n        // rebuild children w/o data \n        function noData(node){\n          \n          // active: true\n          // createdAt: 1524632541511\n          // name: \"platform_nodes\"\n          // nodeId: \"5ae00bdd6b2f710021b72238\"\n          // nodes: (86)\n          // parent: Node,\n          // placeholder: false\n          // type: \"platform_nodes:Qmtlksjflsdjfljf\"\n          // updatedAt: null\n          // _id: \"5ae00bdd6b2f710021b72239\"\n          // _path: \"app_store_cloud.platform_nodes\"\n          // _root: Node,\n          // _rootChain: (2) []\n          \n          let newNode = universe.lodash.pick(node, [\n            'type',\n            'name',\n            'placeholder',\n            'createdAt',\n            'updatedAt'\n          ])\n          delete newNode.data;\n          newNode.nodes = [];\n          if(node.nodes){\n            node.nodes.forEach(tmpNode2=>{\n              newNode.nodes.push(noData(tmpNode2));\n            })\n          }\n          return newNode;\n        }\n        \n        for(let tmpNode of nodes){\n          returnNodes.push(noData(tmpNode));\n        }\n        \n      }\n      \n      \n      let response = universe.cJSON.stringify(returnNodes)\n\t\t\t\n      await universe.httpResponse('send', response);\n      \n      return resolve(true);\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"}
  // }) 
  // await App.secondAI.MySecond.putNodeAtPath('data.second.default.routes.api_get',{
  //   type: 'types.second.default.route',
  //   data: {
  //     "priority": 1,
  //     "routes": [
  //       "/api/get"
  //     ],
  // "auth":{
  //   "loggedin":true}
  //   }
  // }) 
  // await App.secondAI.MySecond.putNodeAtPath('data.second.default.routes.api_get.code',{
  //   type: 'types.second.default.code.js',
  //   data: {"code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      console.log('--incoming_route_handler: /api/get --');\n      \n      // This is just temporary! \n      \n      let bodyNode = INPUT.data.req.body;\n      \n      console.log('bodyNode:', bodyNode);\n      \n  \t\t// expecting an _id! \n  \t\t\n  \t\tif(!bodyNode.name){\n        await universe.httpResponse('send', false);\n  \t\t  return false;\n  \t\t}\n  \t\t\n  \t\t// run execService \n      let node = await universe.getNodeAtPath(bodyNode.name);\n      \n      let response = universe.cJSON.stringify(node)\n\t\t\t\n      await universe.httpResponse('send', response);\n      \n      return resolve(true);\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"}
  // }) 
  // await App.secondAI.MySecond.putNodeAtPath('data.second.default.routes.api_put',{
  //   type: 'types.second.default.route',
  //   data: {
  //     "priority": 1,
  //     "routes": [
  //       "/api/put"
  //     ],
  // "auth":{
  //   "loggedin":true}
  //   }
  // }) 
  // await App.secondAI.MySecond.putNodeAtPath('data.second.default.routes.api_put.code',{
  //   type: 'types.second.default.code.js',
  //   data: {"code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      console.log('--incoming_route_handler: /put (for a path) --');\n      \n      let bodyNode = INPUT.data.req.body;\n      \n  \t\t// expecting a valid _path \n  \t\t\n  \t\tif(!bodyNode.name){\n  \t\t  console.error('Missing name in body for node');\n        await universe.httpResponse('send', false);\n  \t\t  return false;\n  \t\t}\n  \t\t\n  \t\tlet node = {\n  \t\t  type: bodyNode.type,\n  \t\t  data: bodyNode.data,\n  \t\t}\n      \n      let opts = {};\n      let key;\n        \n      // console.log('putNodeAtPath', bodyNode.name, node);\n      let result = await universe.putNodeAtPath(bodyNode.name, node, key, opts);\n      \n      // console.log('Result of saving putNodeAtPath (new node w/ _id)', result);\n      \n      let secondResponseNode = {\n        type: 'types.second.default.response',\n        data: {\n          result\n        }\n      }\n      \n      await universe.httpResponse('send', secondResponseNode);\n      \n      return resolve(true);\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"}
  // }) 
  // await App.secondAI.MySecond.putNodeAtPath('data.second.default.routes.api_remove',{
  //   type: 'types.second.default.route',
  //   data: {
  //     "priority": 1,
  //     "routes": [
  //       "/api/remove"
  //     ],
  // "auth":{
  //   "loggedin":true}
  //   }
  // }) 
  // await App.secondAI.MySecond.putNodeAtPath('data.second.default.routes.api_remove.code',{
  //   type: 'types.second.default.code.js',
  //   data: {"code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      console.log('--incoming_route_handler: /api/remove (for a path) --');\n      \n      let bodyNode = INPUT.data.req.body;\n      \n  \t\t// expecting a valid name \n  \t\t\n  \t\tif(!bodyNode.name){\n  \t\t  console.error('Missing name in body for node');\n        await universe.httpResponse('send', false);\n  \t\t  return false;\n  \t\t}\n  \t\t\n      let opts = {};\n        \n      console.log('removeNodeAtPath', bodyNode.name);\n      let result = await universe.removeNodeAtPath(bodyNode.name, opts);\n      \n      console.log('Result of removeNodeAtPath', result);\n      \n      let secondResponseNode = {\n        type: 'types.second.default.response',\n        data: {\n          result\n        }\n      }\n      \n      await universe.httpResponse('send', secondResponseNode);\n      \n      return resolve(true);\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"}
  // }) 
  // //   await App.secondAI.MySecond.putNodeAtPath('app.second.deveditor.frontend.data.react_components.main',{
  // //     type: 'types.second.default.code.js',
  // //     data: {
  // //   "code": "(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n  \n      console.log('---Startup Component----');\n      \n      let sleep = function(ms){\n        return new Promise((resolve,reject)=>{\n          universe.setTimeout(resolve,ms);\n        })\n      }\n      \n      const AceEditor = universe.AceEditor;\n      const ReactResizeDetector = universe.ReactResizeDetector;\n      const RecreateChildOnPropsChange = universe.RecreateChildOnPropsChange;\n      \n      const Router = universe.ReactRouterDomRouter;\n      const Route = universe.ReactRouterDomRoute;\n      const Switch = universe.ReactRouterDomSwitch;\n      \n      class EmbeddedComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              embeddedComponenthere\n            </div>\n          )\n        }\n      }\n      \n      let ErrorComponent = (name) => {\n        return class ErrorComponent extends React.Component {\n          constructor(props){\n            super(props);\n          }\n          render(){\n            return (\n              <div>\n                ErrorLoading: {name || 'unknown'}\n              </div>\n            )\n          }\n        }\n      }\n      \n      class mycomponent extends React.Component {\n        constructor(props){\n          super(props);\n          \n          WINDOW.appBaseUrl = WINDOW.appBaseUrl || '/deveditor';\n          \n          this.state = {}\n          \n        }\n        \n        componentDidMount(){\n          \n          console.log('MainComponent didMount');\n          \n          // this.startUp();\n            \n            \n        }\n        \n        @autobind\n        async startUp(){\n          \n          // Fetch default nodes (Language NodeChain, Identity, etc.) \n          await this.fetchDefaultNodes();\n          \n          await this.loadComponents();\n          \n          // if identity includes a logged-in profile\n          // - show the main page \n          // - else: \n          //   - see if hash exists in url (token, after login) \n          //   - redirect to login if no hash to process\n          \n          console.log('MainComponent loaded startUp');\n        \n        }\n        \n        @autobind\n        async loadComponents(){\n          \n          // Not async for setState! \n          \n          let components = [\n            'DefaultLayout',\n            'MainDeveloperComponent',\n            'MainDeveloperNodesComponent',\n            'MainDirectTalkComponent',\n            'MainDirectRawComponent',\n            'Main404Component'\n          ];\n          \n          for(let componentInternalId of components){\n            try {\n                \n              let Component = await this.props.loadComponent({\n                internalId: componentInternalId\n              });\n              let obj = {};\n              obj[componentInternalId] = Component;\n              this.setState(obj)\n              // console.log(componentInternalId,Component);\n              \n            }catch(err){\n              console.error(\"Failed loading component:\",componentInternalId);\n            }\n          }\n          \n        }\n        \n        render(){\n          \n          const DefaultLayout = this.state.DefaultLayout || ErrorComponent('DefaultLayout');\n          const MainDeveloperNodesComponent = this.state.MainDeveloperNodesComponent || ErrorComponent('MainDeveloperNodesComponent');\n          const Main404Component = this.state.Main404Component || ErrorComponent('Main404Component');\n          \n          // if(this.state.renderLogin){\n          //   return this.renderLoginComponent();\n          // }\n          return (\n            <div>TestMain</div>\n          )\n          \n          // return (\n          //   <Router basename={WINDOW.appBaseUrl}>\n          //     <Switch>\n              \n          //       <DefaultLayout exact path=\"/\" component={MainDeveloperNodesComponent} />\n                \n          //       {/* Fallback (404) */}\n          //       <DefaultLayout path=\"/\" component={Main404Component} />\n                \n          //     </Switch>\n          //   </Router>\n          // )\n        }\n      }\n      \n      mycomponent = universe.ReactGlobalState(mycomponent);\n      mycomponent = universe.ReactHelpers(mycomponent);\n      \n      resolve({\n        type: 'types.second.default.react_component',\n        data: mycomponent\n      });\n      \n    }catch(err){\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()"
  // // }
  // //   }) 
  // //   await App.secondAI.MySecond.putNodeAtPath('app.second.deveditor.frontend.data.react_components.main.404',{
  // //     type: 'types.second.default.react_component.js',
  // //     data: {
  // //   "code": "(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      const Link = universe.ReactRouterDomLink;\n      \n      class mycomponent extends React.Component {\n        constructor(props){\n          super(props)\n          this.state = {}; \n        }\n      \n        render(){\n          return (\n            <div className=\"full-screen\">\n              404 - Missing route in frontend app \n            </div>\n          )\n        }\n      };\n      \n      mycomponent = universe.ReactGlobalState(mycomponent);\n      mycomponent = universe.ReactHelpers(mycomponent);\n      \n      resolve({\n        type: 'types.second.default.react_component',\n        data: mycomponent\n      });\n      \n    }catch(err){\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()"
  // // }
  // //   }) 
  // //   await App.secondAI.MySecond.putNodeAtPath('app.second.deveditor.frontend.data.react_components.main.default_layout',{
  // //     type: 'types.second.default.react_component.js',
  // //     data: {
  // //   "code": "(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      const AceEditor = universe.AceEditor;\n      const ReactResizeDetector = universe.ReactResizeDetector;\n      const RecreateChildOnPropsChange = universe.RecreateChildOnPropsChange;\n      \n      const Router = universe.ReactRouterDomRouter;\n      const Route = universe.ReactRouterDomRoute;\n      const Switch = universe.ReactRouterDomSwitch;\n      \n      const Link = universe.ReactRouterDomLink;\n      \n      class EmbeddedComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              embeddedComponenthere\n            </div>\n          )\n        }\n      }\n      \n      class ErrorComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        render(){\n          return (\n            <div>\n              ErrorLoading\n            </div>\n          )\n        }\n      }\n      \n      \n      class mycomponent extends React.Component {\n        constructor(props){\n          super(props)\n          this.state = {};\n          \n          // WINDOW.UpdateApp = this.handleUpdateApp;\n          // WINDOW.UpdateAppRemote = this.handleUpdateRemote;\n          \n          console.log('DefaultLayout init');\n          \n        }\n      \n        render(){\n          const { component: Component, ...rest } = this.props;\n          \n          return (\n            <Route {...rest} render={matchProps => (\n                \n              <div className=\"full-screen\">\n                <div className=\"flex-header\">\n                  \n                  <nav className=\"navbar is-transparent\" style={{zIndex:1}}>\n                    <div className=\"navbar-brand\">\n                      <Link className=\"navbar-item\" to=\"/\">\n                        <h1 className=\"title is-4 truncate\" style={{width:\"350px\"}}>\n                          DevEditor\n                        </h1>\n                      </Link>\n                      <div className=\"navbar-burger burger\" data-target=\"navbarExampleTransparentExample\">\n                        <span></span>\n                        <span></span>\n                        <span></span>\n                      </div>\n                    </div>\n                  \n                    <div id=\"navbarExampleTransparentExample\" className=\"navbar-menu\">\n                      <div className=\"navbar-start\">\n                      \n                        {/*\n                        <Link className=\"navbar-item\" to=\"/raw\">\n                          Raw Request\n                        </Link>\n                        */}\n                        \n                      </div>\n                      <div className=\"navbar-end\">\n                      \n                        <div className=\"navbar-item dropdown is-hoverable is-right\">\n                          <div className=\"dropdown-trigger\">\n                                                    \n                            <button className={\"button is-small\" + ((this.props.state.updatingLocal || this.props.state.updatingRemote) ? ' is-loading':'')}>\n                              <span>\n                              \n                                {/*\n                                  !username ? 'Loading User':\n                                  <span>\n                                    {username}\n                                  </span>\n                                */}\n                                \n                              </span>\n                              <span className=\"icon is-small\">\n                                <i className=\"fa fa-angle-down\"></i>\n                              </span>\n                            </button>\n                          </div>\n                          <div className=\"dropdown-menu\" style={{top:\"0px\"}}>\n                            <div className=\"dropdown-content\">\n                              \n                              <Link className=\"dropdown-item\" to='/settings'>\n                                Settings (old)\n                              </Link>\n                              \n                              <div className='dropdown-divider'></div>\n                              \n                              <a className=\"dropdown-item\" onClick={this.handleUpdateApp}>\n                                Update App (todo)\n                              </a>\n                              \n                            </div>\n                          </div>\n                        </div>\n                          \n                      </div>\n                    </div>\n                    \n                  </nav>\n                  \n                </div>\n                \n                <Component {...matchProps} />\n                \n                <div className=\"flex-footer\">\n                  &nbsp;\n                </div>\n                \n                <ReactResizeDetector handleWidth handleHeight onResize={(w,h)=>this.props.setState({newWindowSize:[w,h]})} />\n                \n                \n              </div>\n              \n            )} />\n          )\n        }\n      };\n      \n      mycomponent = universe.ReactGlobalState(mycomponent);\n      mycomponent = universe.ReactHelpers(mycomponent);\n      \n      resolve({\n        type: 'types.second.default.react_component',\n        data: mycomponent\n      });\n      \n    }catch(err){\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()"
  // // }
  // //   }) 
  // //   await App.secondAI.MySecond.putNodeAtPath('app.second.deveditor.frontend.data.react_components.main.developer_window',{
  // //     type: 'types.second.default.react_component.js',
  // //     data: {
  // //   "code": "(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      const AceEditor = universe.AceEditor;\n      const ReactResizeDetector = universe.ReactResizeDetector;\n      const RecreateChildOnPropsChange = universe.RecreateChildOnPropsChange;\n      \n      const Link = universe.ReactRouterDomLink;\n      \n      \n      let ErrorComponent = (name) => {\n        return class ErrorComponent extends React.Component {\n          constructor(props){\n            super(props);\n          }\n          render(){\n            return (\n              <div>\n                ErrorLoading from Main: {name || 'unknown'}\n              </div>\n            )\n          }\n        }\n      }\n      \n      class mycomponent extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {\n            browserList: null,\n            remoteList: null,\n            mainEditor: null,\n            remoteFriendList: null,\n            remoteFriendDataList: null\n            // browser: null,\n          }\n        }\n        \n        componentDidMount(){\n          return new Promise(async (resolve,reject)=>{\n            await this.loadComponents();\n          \n          });\n        }\n        \n        @autobind\n        async loadComponents(){\n          \n          // Not async for setState! \n          \n          let components = [\n            'data.react_components.main.developer_window.left_browser',\n            'data.react_components.main.developer_window.editor',\n          ];\n          \n          for(let componentPath of components){\n            try {\n              console.log('Getting component:', componentPath);\n              let Component = await universe.getNode(componentPath);\n              Component = await universe.runInVM(Component,{});\n              let obj = {};\n              let k = 'Component_' + componentPath.split('.').pop();\n              obj[k] = Component.data;\n              this.setState(obj)\n              // console.log(componentInternalId,Component);\n              \n            }catch(err){\n              console.error(\"Failed loading component:\",err);\n            }\n          }\n          \n        }\n        \n        @autobind\n        handleTest(){\n          this.setState({\n            value: this.state.value + 1\n          })\n        }\n        \n        @autobind\n        async handleClearMemory(){\n          \n          await universe.clearMemory();\n          WINDOW.location.reload();\n          \n        }\n        \n        \n        render(){\n          \n          const Component_left_browser = this.state.Component_left_browser || ErrorComponent('Component_left_browser');\n          const Component_editor = this.state.Component_editor || ErrorComponent('Component_editor');\n          \n          return (\n            <div className=\"flex-main\">\n              <div className=\"flex-left\" style={{padding:'4px', width: '450px'}}>\n                \n                <div>\n                  <Component_left_browser />\n                </div>\n                \n              </div>\n              <div className=\"flex-middle\">\n                \n                {\n                  this.props.state.editingNode ?\n                  <RecreateChildOnPropsChange \n                      node={this.props.state.editingNode}\n                      editorComponent={Component_editor}\n                    >\n                    <Component_editor\n                      node={this.props.state.editingNode}\n                    />\n                  </RecreateChildOnPropsChange>\n                  :''\n                }\n                \n              </div>\n              <div className=\"flex-right\" style={{width:'10px'}}>\n                \n                {/*\n                <div>\n                  <RemoteFriendListComponent />\n                </div>\n                */}\n                \n              </div>\n            </div>\n          )\n        }\n      }\n      \n      mycomponent = universe.ReactGlobalState(mycomponent);\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: mycomponent\n      });\n      \n    }catch(err){\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()"
  // // }
  // //   }) 
  // //   await App.secondAI.MySecond.putNodeAtPath('app.second.deveditor.frontend.data.react_components.main.developer_window.editor',{
  // //     type: 'types.second.default.react_component.js',
  // //     data: {
  // //   "code": "(()=>{\n  \n  \n  let __parsedFiles = {};\n  function jsonParse(key, contents){\n    if(__parsedFiles[key]){\n      return __parsedFiles[key]\n    }\n  \n    __parsedFiles[key] = JSON.parse(contents);\n    return __parsedFiles[key];\n  \n  }\n  \n  \n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      const AceEditor = universe.AceEditor;\n      \n      class mycomponent extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {\n            mainTab: '__ALL__',\n            aceHeight: 100,\n            windowHeight: 100,\n            pastable: false,\n            pasteText: '',\n            isPublishing: false,\n            saving: false,\n            updatingGit: false,\n            chainNodes: [],\n            nodeChains: null\n          }\n        }\n        \n        componentDidMount(){\n          console.log('Editor componentDidMount2');\n          this.resizeAce();\n          this.handleKeyDown();\n          \n          this.loadSchema();\n          this.fetchParentsOfNodesToLearn();\n          this.checkForCodeUpdates();\n          \n          universe.EE.on('nodes-modified', this.fetchParentsOfNodesToLearn);\n          universe.EE.on('nodes-modified', this.loadSchema);\n          universe.EE.on('nodes-modified', this.checkForCodeUpdates);\n          \n        }\n        \n        componentWillUnmount(){\n          \n          universe.EE.removeListener('nodes-modified', this.fetchParentsOfNodesToLearn);\n          universe.EE.removeListener('nodes-modified', this.loadSchema);\n          universe.EE.removeListener('nodes-modified', this.checkForCodeUpdates);\n          \n        }\n        \n        componentWillReceiveProps(nextProps, nextState){\n          \n          // resizing helpers for Ace height\n          if(!nextProps.state.newWindowSize || \n            this.state.windowHeight != nextProps.state.newWindowSize[1]){\n            this.setState({\n              aceHeight: 0\n            },()=>{\n              this.resizeAce();\n            })\n          }\n          if(nextState.aceHeight == -1){\n            this.setState({\n              aceHeight: 0\n            },()=>{\n              this.resizeAce();\n            })\n          }\n          // if(nextProps.state.editingNode && this.props.node){\n          //   if(nextProps.state.editingNode._id != this.props.node._id){\n          //     this.setState({\n          //       mainTab: '__ALL__'\n          //     })\n          //   }\n          // }\n          // console.log('nextProps:', nextProps);\n        }\n        \n        @autobind\n        resizeAce(){\n          if(!this.parentRef){\n            this.setState({\n              aceHeight: null\n            })\n            return;\n          }\n          // console.log('Resize ace', this.parentRef.offsetHeight);\n          this.setState({\n            aceHeight: this.parentRef.offsetHeight\n          },()=>{\n            if(this.aceRef){\n              this.aceRef.editor.resize();\n            }\n          })\n        }\n        \n        @autobind\n        refetchNode(){\n          return new Promise(async (resolve,reject)=>{\n            \n            console.error('Not refetching node now');\n            return false;\n            \n            let node = this.props.node;\n              \n            try {\n              \n              this.setState({\n                fetchingRemote: true\n              })\n              \n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                          {\n                            matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                            dataForAction: {\n                              type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              data: {\n                                dataFilter: {\n                                  _id: node._id\n                                },\n                                matchFunctionNode: {\n                                  // query here!\n                                  // action_pointer:0.0.1:local:238972ncr\n                                  type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                  data: {\n                                    code: `(()=>{\n                                      // Action \n                                      // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                      \n                                      let inputNode = INPUT.data.inputNode;\n                                      \n                                      if(inputNode._id != '${node._id}'){\n                                        return false;\n                                      }\n                                      \n                                      return inputNode;\n                                      \n                                    })()`\n                                  }\n                                },\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              let nodes = response.data.actionResponses[1].data;\n              \n              // expecting single result \n              // let componentNode = await universe.runInVM(result[0],{});\n              \n              // this resets the component! (remount, etc.) \n              this.props.setState({\n                editingNode: nodes[0]\n              })\n              \n              resolve();\n              \n              \n            } catch(err){\n              console.error('Failed refetching editingNode');\n              \n              this.setState({\n                fetchingRemote: false\n              })\n              \n              reject();\n              \n            }\n            \n          });\n          \n          // this.props.setState({\n          //   editingNode: node\n          // })\n          \n        }\n      \n        @autobind\n        async loadSchema(){\n          // from NodeChain \n          // - temporarily using an odd slug (without ipfs hash) \n          \n          // let node = this.props.node;\n          let node = this.props.editStateToObj();\n          \n          console.log('LOAD SCHEMA1', node);\n          \n          // let slug = this.props.node.type;\n          let slug = node.type;\n          \n          let schemaObj;\n            \n          let parsed = slug.split(':');\n          let slicedType;\n          try {\n            slicedType = parsed[1].slice(0,2);\n          }catch(err){}\n          let mainTab;\n          if(slicedType == 'Qm'){\n            console.log('IPFS Hash:', parsed[1]);\n            \n            let fileNode = await universe.ipfs.files.cat(parsed[1]);\n            console.log('fileNode:', fileNode);\n            fileNode = JSON.parse(fileNode);\n            schemaObj = fileNode.data.schema;\n            \n            // choose default tab if exists\n            mainTab = this.state.mainTab;\n            try {\n              if(schemaObj.properties.code){\n                mainTab = 'code';\n              }\n            }catch(err){}\n            \n            this.setState({\n              schema: schemaObj, // jsSchema\n              mainTab\n            })\n            \n          } else {\n            \n            console.log('using \"any\" schema', node);\n            \n            // use an \"any\" schema object\n            schemaObj = {\n              type: 'object'\n            };\n            try {\n              if(node.data.hasOwnProperty('code')){\n                mainTab = 'code';\n              }\n            }catch(err){\n              // an error here is expected/ok     \n              // console.error('get code prop error:', err);\n            }\n            \n            console.log('mainTab:', mainTab);\n            \n            if(!mainTab){\n              mainTab = '__ALL__';\n            }\n            \n            this.setState({\n              schema: schemaObj, // jsSchema\n              mainTab\n            })\n            \n          }\n          \n        }\n      \n        @autobind\n        loadSchemaOLD(slug){\n          // from Languages server \n      \n          let data = JSON.parse('{\"operationName\":null,\"variables\":{\"slug\":\"'+slug+'\"},\"query\":\"query ($slug: String) {  viewer { language { one(filter: {slug: $slug}) {    _id    slug    title    schemaCode    schemaObj    createdAt    updatedAt    __typename  }}}}\"}');\n          data = JSON.stringify(data);\n          universe.$.ajax({\n            url: 'http://lang.second.ngrok.io/graphql',\n            method: 'post',\n            contentType: 'application/json',\n            data: data,\n            success: languageResult=>{\n              // console.log('Languages', languageResult);\n              if(!languageResult.data.viewer.language.one){\n                console.error('Missing Schema for this type!');\n                this.setState({\n                  schema: false\n                })\n                return;\n              }\n              console.log('have Schema:', languageResult);\n              \n              let schemaObj = languageResult.data.viewer.language.one.schemaObj;\n              \n              // choose default tab if exists\n              let mainTab = this.state.mainTab;\n              try {\n                if(schemaObj.properties.code){\n                  mainTab = 'code';\n                }\n              }catch(err){}\n              \n              this.setState({\n                schema: schemaObj, // jsSchema\n                mainTab\n              })\n            },\n            error: err=>{\n              console.error('Failed fetching languages:', err);\n            }\n          })\n      \n        }\n      \n        @autobind\n        async handleSaveNew(){\n        \n          console.log('Saving updates (new)');\n      \n          let dataBeforeParse = this.props.editState.fields.data.value;\n      \n          let realData;\n    \n          try {\n            realData = JSON.parse(dataBeforeParse);\n          }catch(err){\n            return false;\n          }\n      \n          // create it on the server \n          let nodeToSave = {\n            name: this.props.node.name,\n            data: realData, // type should be correct! ,\n            updatedAt: (new Date()).getTime()\n            // schemaObj: JSON.parse(outputVal)\n          }\n          \n          this.setState({\n            saving: true\n          })\n          \n          universe.$.ajax({\n            url: '/api/put',\n            method: 'post',\n            contentType: 'application/json',\n            data: JSON.stringify(nodeToSave),\n            success: result=>{\n              console.log('Saved!');\n                \n              this.setState({\n                saving: false\n              })\n            },\n            error: errr=>{\n                \n              this.setState({\n                saving: false\n              })\n              \n              WINDOW.alert('Failed to save');\n            }\n          });\n          \n        }\n      \n        @autobind\n        async saveDataUpdates(){\n        \n          console.log('Saving updates (old)');\n      \n          let dataBeforeParse = this.props.editState.fields.data.value;\n      \n          let realData;\n    \n          try {\n            realData = JSON.parse(dataBeforeParse);\n          }catch(err){\n            return false;\n          }\n      \n          // create it on the server \n          let nodeToSave = {\n            _id: this.props.node._id,\n            data: realData, // type should be correct! ,\n            updatedAt: (new Date()).getTime()\n            // schemaObj: JSON.parse(outputVal)\n          }\n          \n          this.makeSaveRequest(nodeToSave);\n        \n        }\n        \n        @autobind\n        fetchParentsOfNodesToLearn(){\n          return new Promise(async (resolve, reject)=>{\n            \n            // unnecessary\n            return resolve();\n            \n            this.setState({\n              fetchingParents: true\n            })\n            \n            let parentNodes = [];\n            try {\n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                          {\n                            matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                            dataForAction: {\n                              type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              data: {\n                                dataFilter: {\n                                  nodeId: null\n                                },\n                                matchFunctionNode: {\n                                  // query here!\n                                  // action_pointer:0.0.1:local:238972ncr\n                                  type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                  data: {\n                                    code: `(()=>{\n                                      // Action \n                                      // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                      \n                                      let inputNode = INPUT.data.inputNode;\n                                      \n                                      if(inputNode.nodeId){\n                                        return false;\n                                      }\n                                      \n                                      if(inputNode.type.split(':')[0] != \"parent_of_nodes_to_learn\"){\n                                        return false;\n                                      }\n                                      \n                                      if(inputNode.data.environment != \"browser\"){\n                                        return false;\n                                      }\n                                      \n                                      return inputNode;\n                                      \n                                    })()`\n                                  }\n                                },\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              parentNodes = response.data.actionResponses[1].data;\n              \n              console.log('parentNodes updated');\n            }catch(err){\n              console.error('Failed updating parentNodes');\n            }\n            \n            this.setState({\n              parentNodes,\n              fetchingParents: false\n            })\n            \n            resolve(parentNodes);\n            \n          });\n        }\n      \n        @autobind\n        async handleMove(){\n          \n          let originalName = this.props.node.name;\n          \n          let name = WINDOW.prompt('move to:', originalName);\n          if(name == originalName){\n            return false;\n          }\n    \n          name = name.trim().toLowerCase();\n          \n          if(name == originalName){\n            // trying to move to same (so do nothing) \n            return false;\n          }\n\n          // create new, then remove old \n          let nodeToSave = {\n            name, // name should be correct! ,\n            type: this.props.node.type,\n            data: this.props.node.data,\n            // updatedAt: (new Date()).getTime()\n            // schemaObj: JSON.parse(outputVal)\n          }\n          \n          await this.makeSaveRequest(nodeToSave);\n          \n          // TODO: await save confirmation \n        \n          // remove old \n          this.setState({\n            saving: true\n          });\n            \n          let removeOldResponse = await universe.$.ajax({\n            url: '/api/remove',\n            method: 'post',\n            contentType: 'application/json',\n            data: JSON.stringify({name: originalName})\n          });\n        \n          this.setState({\n            saving: false\n          });\n          \n          \n          // TODO: load the new node\n          try {\n            universe.EE.emit('nodes-modified', '');\n          }catch(err){\n            console.error(err);\n          }\n          \n          this.props.setState({\n            editingNode: null\n          })\n            \n          return true;\n        \n        }\n      \n        @autobind\n        async handleUpdateType(){\n        \n          let type = WINDOW.prompt('Type:',this.props.node.type);\n          if(!type){\n            return false;\n          }\n    \n          type = type.trim();\n\n          // create it on the server \n          let nodeToSave = {\n            _id: this.props.node._id,\n            type, // type should be correct! ,\n            updatedAt: (new Date()).getTime()\n            // schemaObj: JSON.parse(outputVal)\n          }\n          \n          this.makeSaveRequest(nodeToSave);\n        \n        }\n      \n        @autobind\n        async handleUpdateParent(){\n          \n          console.log('Node:', this.props.node);\n          \n          let nodeId = WINDOW.prompt('Parent Node ID (\"null\" for root):',this.props.node.nodeId || '');\n          if(!nodeId){\n            return false;\n          }\n    \n          nodeId = nodeId.trim();\n          \n          if(!nodeId.length){\n            nodeId = null;\n          }\n          \n          if(nodeId == 'null'){\n            nodeId = null;\n          }\n  \n          // create it on the server \n          let nodeToSave = {\n            _id: this.props.node._id,\n            nodeId,\n            updatedAt: (new Date()).getTime()\n            // schemaObj: JSON.parse(outputVal)\n          }\n          \n          this.makeSaveRequest(nodeToSave);\n        \n        }\n      \n        @autobind\n        handleDuplicate(){\n          \n          return new Promise(async (resolve,reject)=>{\n            \n            // let node = this.props.node;\n            let node = this.props.editStateToObj();\n            \n            console.log('NODE:', node);\n            \n            let doChildren;\n            if(node.nodes && node.nodes.length){\n              doChildren = WINDOW.prompt('Keep child nodes? (y/n)','y');\n              if(!doChildren || (doChildren != 'y' && doChildren != 'n') ){\n                return false;\n              }\n            }\n      \n            console.log('NODE:', node);\n      \n            // // Send in a Node that will be learned by the AI \n            // {\n            //   type: 'forced_learn_node:0.0.1:local:34907234987sf23',\n            //   data: {\n            //     // what to import! \n            //     _id: \"testingid2\",\n            //     nodeId: null,\n            //     type: \"emoji:0.0.1:local:2f9jsd98fj293fsdf\",\n            //     // expected/allowed schemas for return \n            //     data: {\n            //       emoji: \"joy\"\n            //     }\n            //   }\n            // },\n      \n            \n            let name = WINDOW.prompt('node name', node.name + '_' + Date.now());\n            if(!name){\n              return false;\n            }\n            \n            // New key, if CodeNode?\n            \n            let newKey;\n            if(node.data && node.data.key){\n              newKey = WINDOW.prompt('New uuid key for node?','y');\n              if(newKey == 'y'){\n                newKey = universe.uuidv4();\n              } else {\n                newKey = null;\n              }\n            }\n            \n            // Create this new one, then iterate down the tree of kids \n            // - if this one has a nodeId, ask if we want to keep it? \n            let confirmed = WINDOW.prompt('Save for sure?','y');\n            if(confirmed != 'y'){\n              return false;\n            }\n      \n            this.setState({\n              saving: true\n            });\n            \n            // iterate\n            // - save this one, then start saving down tree\n            let newNode = {\n              name,\n              type: node.type,\n              data: JSON.parse(JSON.stringify(node.data)),\n            }\n            \n            if(newKey){\n              newNode.data.key = newKey;\n            }\n      \n            let savedNode = await this.makeSaveRequest(newNode, {}, true);\n            \n            console.log('Saved Node', savedNode);\n          \n            const saveChildNodes = (parentNode, childNodes) => {\n              return new Promise(async (resolve, reject)=>{\n      \n                console.log('Saving children');\n                \n                for(let tmpNode of childNodes){\n                  let newChildNode = {\n                    name: parentNode.name + '.' + tmpNode.name.split('.').pop(),\n                    type: tmpNode.type,\n                    data: tmpNode.data,\n                  }\n                  let savedChildNode = await this.makeSaveRequest(newChildNode, {}, true);\n      \n                  if(tmpNode.nodes && tmpNode.nodes.length){\n      \n                    await saveChildNodes(parentNode, tmpNode.nodes);\n      \n                  }\n                }\n                resolve();\n              });\n            }\n      \n            if(doChildren == 'y'){\n              await saveChildNodes(newNode, node.nodes);\n            }\n            \n            // console.log('rebuilding memory on remote, after bulk updates');\n            // await this.makeRebuildMemoryRequest();\n            \n            console.log('Done duplicating');\n      \n            try {\n              universe.EE.emit('nodes-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n            this.setState({\n              saving: false\n            });\n      \n            // window.location = '/node/' + savedNode._id;\n      \n          });\n      \n        }\n      \n        @autobind\n        handleAddChild(){\n      \n          return new Promise(async (resolve,reject)=>{\n      \n            // let node = this.props.node;\n            let node = this.props.editStateToObj();\n      \n            let type;\n            type = WINDOW.prompt('Type','');\n            if(!type){\n              return false;\n            }\n            \n            type = type.trim();\n            \n            let name;\n            name = WINDOW.prompt('Name',universe.uuidv4());\n            if(!name){\n              return false;\n            }\n            \n            // todo: get and validate the type's schema. use schema for default data\n            \n            this.setState({\n              saving: true\n            });\n      \n            let newNode = {\n              name: name,\n              nodeId: node._id,\n              type: type,\n              data: null\n            }\n      \n            console.log('newNode:', newNode);\n      \n            let savedNode = await this.forceNewNode(newNode, {});\n            \n            console.log('Saved Node', savedNode);\n          \n            console.log('Done creating new');\n      \n            try {\n              universe.EE.emit('nodes-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n            this.setState({\n              saving: false\n            });\n      \n            // window.location = '/node/' + savedNode._id;\n      \n          });\n      \n        }\n        \n        @autobind\n        handleAddChildPaste(){\n          \n          return new Promise(async (resolve,reject)=>{\n      \n            let nodeText = this.state.pasteText; //WINDOW.prompt('Node JSON String','');\n            if(!nodeText){\n              return false;\n            }\n            \n            let nodes = JSON.parse(nodeText);\n            console.log('Nodes input:', nodes);\n            \n            // Single Node, or Multiple? \n            if(!universe.lodash.isArray(nodes)){\n              // single node\n              nodes = [nodes];\n            }\n            \n            // Create this new one, then iterate down the tree of kids \n            // - if this one has a nodeId, ask if we want to keep it? \n            let confirmed = WINDOW.prompt('Save node(s) and children for sure?','y');\n            if(confirmed != 'y'){\n              return false;\n            }\n            \n            for(let node of nodes){\n            \n              // iterate\n              // - save this one, then start saving down tree\n              let newNode = {\n                name: node.name,\n                nodeId: this.props.node._id, \n                type: node.type,\n                data: node.data,\n              }\n        \n              console.log('newNode:', newNode);\n        \n              let savedNode = await this.forceNewNode(newNode, {skipWaitForResolution: true, skipRebuild: true}, true);\n              \n              console.log('Saved Node');\n            \n              const saveChildNodes = (nodeId, childNodes) => {\n                return new Promise(async (resolve, reject)=>{\n        \n                  console.log('Saving children');\n                  \n                  for(let tmpNode of childNodes){\n                    let newChildNode = {\n                      name: tmpNode.name,\n                      nodeId,\n                      type: tmpNode.type,\n                      data: tmpNode.data,\n                    }\n                    let savedChildNode = await this.forceNewNode(newChildNode, {skipWaitForResolution: true, skipRebuild: true}, true);\n        \n                    if(tmpNode.nodes && tmpNode.nodes.length){\n        \n                      await saveChildNodes(savedChildNode.data._id, tmpNode.nodes);\n        \n                    }\n                  }\n                  resolve();\n                });\n              }\n        \n              await saveChildNodes(savedNode.data._id, node.nodes);\n              \n            }\n            \n            console.log('rebuilding memory on remote, after bulk updates');\n            await this.makeRebuildMemoryRequest();\n            \n            console.log('Done Adding via Paste');\n      \n            try {\n              universe.EE.emit('nodes-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n          });\n        }\n        \n        @autobind\n        handleImportZip(){\n          \n          return new Promise(async (resolve,reject)=>{\n            \n            let url = WINDOW.prompt('ZIP URL (github urls parsed automatically)',''); \n            if(!url){\n              return false;\n            }\n            \n        \n            // converts startup git url into username/password \n            // - eventually allow links to be pasted, parse accordingly \n        \n            // parse github links and re-organize to fit .zip model \n        \n            this.setState({\n              saving: true\n            });\n            \n            let gh = universe.parseGitHubUrl(url);\n            if(gh.owner && \n              gh.name && \n              gh.repo && \n              gh.branch){\n              url = `https://github.com/${gh.repo}/archive/${gh.branch}.zip`;\n            }\n        \n            // cannot simply follow github zipball/tarball links :( \n            universe.fetch(`https://cors-anywhere.herokuapp.com/${url}`,{\n              // mode: 'no-cors' \n            })\n            .then(response=>{\n              // console.log('Response:', response);\n              return response.arrayBuffer();\n            })\n            .then(universe.JSZip.loadAsync)\n            .then(async (zip)=>{\n              \n              console.log('loaded zip data!', zip);\n      \n              // ZIP is valid! \n              let files = zip.files;\n      \n              function readFilePath(p){\n                return new Promise(async (resolve,reject)=>{\n                  console.log('path:', p);\n                  let r = await files[p].async('text')\n                  resolve(r);\n                });\n              }\n      \n              // load all the files \n              let allFiles = {};\n              for(let filepath of Object.keys(files)){\n                let file = files[filepath];\n                if(file.dir){\n      \n                } else {\n                  // console.log('filepath:', filepath);\n                  let contents = await readFilePath(filepath);\n                  // console.log('contents:', contents);\n                  let normalizedPath = filepath.split('/').splice(1).join('/');\n                  allFiles[normalizedPath] = contents;\n                }\n              }\n      \n              console.log('allFiles from Zip:', allFiles);\n              \n              // function addChildren(id){\n              //   return new Promise(async (resolve,reject)=>{\n            \n              //     let nodes = [];\n              //       for(let filepath of Object.keys(allFiles)){\n              //       let contents = allFiles[filepath];\n              //       if(filepath.indexOf('nodes/') !== 0){\n              //         // console.log('NOT NODE:', filepath);\n              //         continue;\n              //       }\n      \n              //       let parsed = jsonParse(filepath, contents);\n              //       if(parsed.nodeId == id){\n              //         // console.log('Matches ID:', parsed.nodeId, id);\n              //         let children = await addChildren(parsed._id);\n              //         parsed.nodes = children;\n              //         nodes.push(parsed);\n              //       } else {\n              //         // console.log('No Kids:', id, parsed.nodeId);\n              //       }\n      \n              //     }\n      \n              //     resolve(nodes);\n      \n              //   });\n              // }\n              \n              function addChildren(path){\n                return new Promise(async (resolve,reject)=>{\n                \n                  let nodes = [];\n                  try {\n                      \n                    for(let filepath of Object.keys(allFiles)){\n                      let contents = allFiles[filepath];\n                      if(filepath.indexOf(path) !== 0){\n                        // console.log('NOT NODE:', filepath);\n                        continue;\n                      }\n                      let pathDepth = path.split('/').length;\n                      let filepathDepth = filepath.split('/').length;\n                      if(pathDepth == filepathDepth){\n                        // xyz.json at correct depth\n                        \n                        let parsed = jsonParse(filepath, contents);\n                        // if(parsed.nodeId == id){\n                          // console.log('Matches ID:', parsed.nodeId, id);\n                          let children = await addChildren(filepath.slice(0, filepath.length - 5) + '/'); // remove '.json'\n                          parsed.nodes = children;\n                          nodes.push(parsed);\n                        // } else {\n                        //   // console.log('No Kids:', id, parsed.nodeId);\n                        // }\n                      }\n        \n        \n                    }\n                  }catch(err){\n                    console.error(err);\n                  }\n    \n                  resolve(nodes);\n                  \n                });\n              }\n      \n              // re-organize child nodes \n              let ZipNodes;\n              try {\n                // ZipNodes = await addChildren(null); // start at root, adds children recursively\n                ZipNodes = await addChildren('nodes/'); // start at root, adds children recursively \n              }catch(err){\n                console.error('Failed zipnodes', err);\n                WINDOW.alert('Failed fetching zip nodes');\n              }\n        \n              console.log('ZipNodes:', ZipNodes);\n              \n              // let secondJson = JSON.parse(allFiles['second.json']);\n              // let basicKey = secondJson.name; \n              \n              \n              for(let node of ZipNodes){\n              \n                // iterate\n                // - save this one, then start saving down tree\n                let newNode = {\n                  name: node.name,\n                  nodeId: this.props.node._id, \n                  type: node.type,\n                  data: node.data,\n                }\n          \n                console.log('newNode:', newNode);\n          \n                let savedNode = await this.forceNewNode(newNode, {skipWaitForResolution: true, skipRebuild: true}, true);\n                \n                console.log('Saved Node');\n              \n                const saveChildNodes = (nodeId, childNodes) => {\n                  return new Promise(async (resolve, reject)=>{\n          \n                    console.log('Saving children');\n                    \n                    for(let tmpNode of childNodes){\n                      let newChildNode = {\n                        name: tmpNode.name,\n                        nodeId,\n                        type: tmpNode.type,\n                        data: tmpNode.data,\n                      }\n                      let savedChildNode = await this.forceNewNode(newChildNode, {skipWaitForResolution: true, skipRebuild: true}, true);\n          \n                      if(tmpNode.nodes && tmpNode.nodes.length){\n          \n                        await saveChildNodes(savedChildNode.data._id, tmpNode.nodes);\n          \n                      }\n                    }\n                    resolve();\n                  });\n                }\n          \n                await saveChildNodes(savedNode.data._id, node.nodes);\n                \n              }\n              \n              console.log('rebuilding memory on remote, after bulk updates');\n              await this.makeRebuildMemoryRequest();\n              \n              console.log('Done Adding via Zip');\n          \n              this.setState({\n                saving: false\n              });\n              \n              try {\n                universe.EE.emit('nodes-modified', '');\n              }catch(err){\n                console.error(err);\n              }\n      \n      \n            })\n\n            \n          });\n          \n        }\n      \n        @autobind\n        handleExportNode(){\n      \n          return new Promise(async (resolve,reject)=>{\n      \n            let node = JSON.parse(JSON.stringify(this.props.editStateToObj()));\n            // let node = JSON.parse(JSON.stringify(this.props.node));\n      \n            let confirm;\n            confirm = WINDOW.confirm('Export as JSON (copied to clipboard)?');\n            if(!confirm){\n              return false;\n            }\n            \n            // JSON-ify, export to be imported into browser/etc.\n            // - for the \"learn basics\" Nodes (default ExternalIdentity, capabilities, etc.) \n            let j = JSON.stringify(node);\n            WINDOW.tmpJ = j;\n            // console.log('JSON-ified:', j);\n            // WINDOW.prompt('JSON',WINDOW.btoa(j));\n            universe.copy(j);\n            \n          });\n      \n        }\n      \n        @autobind\n        handleExportChildren(){\n      \n          return new Promise(async (resolve,reject)=>{\n      \n            // let node = JSON.parse(JSON.stringify(this.props.node));\n            let node = JSON.parse(JSON.stringify(this.props.editStateToObj()));\n      \n            let confirm;\n            confirm = WINDOW.confirm('Export as JSON (copied to clipboard)?');\n            if(!confirm){\n              return false;\n            }\n            \n            let nodes = node.nodes || [];\n            nodes = nodes.map(node=>{\n              delete node.nodeId;\n              return node;\n            })\n            \n            console.log('NODES:', nodes);\n            \n            // JSON-ify, export to be imported into browser/etc.\n            // - for the \"learn basics\" Nodes (default ExternalIdentity, capabilities, etc.) \n            let j = JSON.stringify(nodes);\n            WINDOW.tmpJ = j;\n            // console.log('JSON-ified:', j);\n            // WINDOW.prompt('JSON',WINDOW.btoa(j));\n            universe.copy(j);\n            \n          });\n      \n        }\n      \n        @autobind\n        handleExportChildrenToLocalStorage(includeNode){\n          \n          return new Promise(async (resolve,reject)=>{\n      \n            // let node = JSON.parse(JSON.stringify(this.props.node));\n      \n            let node = JSON.parse(JSON.stringify(this.props.editStateToObj()));\n            \n            let nodes;\n            if(includeNode){\n              nodes = [node];\n            } else {\n              nodes = node.nodes || [];\n            }\n            \n            \n            console.log('Local Node Repo Info:', node.data);\n            \n            let storageKey = node.data.name || node.data.repo;\n            \n            \n            let confirm;\n            confirm = WINDOW.confirm('Will overwrite: ' + storageKey);\n            if(!confirm){\n              return false;\n            }\n            \n            // Find the node from the storageKey! \n            // - must be stored in a parent_of_nodes_to_learn tree \n            \n            // parent_of_nodes_to_learn:0.0.1:local:2839fh29\n          \n            // let node = universe.lodash.find(this.state.parentNodes,n=>{\n            //   return n.data.learn == storageKey;\n            // });\n            // console.log('NODE:', node, this.state.parentNodes);\n            // let nodes = JSON.parse(JSON.stringify(node.nodes || []));\n            nodes = nodes.map(node=>{\n              delete node.nodeId;\n              return node;\n            })\n            \n            console.log('NODES:', nodes);\n            \n            // JSON-ify, export to be imported into browser/etc.\n            // - for the \"learn basics\" Nodes (default ExternalIdentity, capabilities, etc.) \n            // let j = JSON.stringify(nodes);\n            // WINDOW.tmpJ = j;\n            // console.log('JSON-ified:', j);\n            // WINDOW.prompt('JSON',WINDOW.btoa(j));\n            // universe.copy(j);\n            \n            let uiApps = await localforage.getItem('possible-ui-apps');\n            uiApps = uiApps || {};\n            \n            uiApps[storageKey] = nodes;\n            \n                  \n            let updatedApps = await localforage.setItem('possible-ui-apps', uiApps);\n            \n            \n          });\n      \n        }\n      \n        @autobind\n        handleCreateGitHubRepoForApp(includeNode){\n      \n          return new Promise(async (resolve,reject)=>{\n            \n            // Repo should NOT already exist! \n            // - we are going to create it on github \n            \n            // \"includeNode\" is used after creation \n            \n            let node = JSON.parse(JSON.stringify(this.props.editStateToObj()));\n      \n            let isOrg = WINDOW.prompt('Is the owner an organization?', 'y');\n            if(!isOrg){\n              return false;\n            }\n            isOrg = (isOrg == 'y') ? true:false;\n            \n            let isPrivate = WINDOW.prompt('Private Repository?', 'n');\n            if(!isPrivate){\n              return false;\n            }\n            isPrivate = (isPrivate == 'y') ? true:false;\n            \n            let owner = node.data.owner || WINDOW.prompt('owner', '');\n            if(!owner){\n              return false;\n            }\n\n            let repo = node.data.repo || WINDOW.prompt('repo', '');\n            if(!repo){\n              return false;\n            } \n            \n            let defaultBranch = 'master';\n            \n            let ghAuth = universe.localStorage.getItem('gh_auth') || '';\n            \n            console.log('ghAuth:', ghAuth);\n            \n            let ghUser;\n            let ghToken;\n            try {\n              if(!ghAuth){\n                ghUser = WINDOW.prompt('GitHub Username:', '');\n                ghToken = WINDOW.prompt('OAuth Token:', '');\n                if(!ghUser || !ghToken){\n                  return false;\n                }\n                ghAuth = [ghUser, ghToken].join(':');\n                universe.localStorage.setItem('gh_auth', ghAuth);\n              }\n              \n              ghUser = ghAuth.split(':')[0];\n              ghToken = ghAuth.split(':')[1];\n            }catch(err){\n              console.error('Failed ghAuth:', err);\n              return false;\n            }\n            \n            // console.log('Setting state...', this, this.setState);\n            \n            this.setState({\n              updatingGit: 'Starting'\n            })\n            \n            // use pre-generated OAuth token for basic auth \n            try {\n              \n              console.log('Local Node Repo Info:', node.data);\n              \n              const gh = new universe.GitHub({\n                username: ghUser,\n                password: ghToken\n              });\n              \n              let RepoOwner,\n                Repo;\n              if(isOrg){\n                RepoOwner = gh.getOrganization(owner);\n              } else {\n                RepoOwner = gh.getUser(owner);\n              }\n              \n              Repo = await RepoOwner.createRepo({\n                name: repo,\n                private: isPrivate\n              });\n              \n              // get instance of repo for writing file \n              Repo = gh.getRepo(owner, repo);\n              \n              \n              // Update the repo with defaults \n              // TODO: \n              // - second.json \n              // - nodes/ (directory) \n              // - .gitignore \n              // - README \n              console.log('Repo:', Repo);\n              let secondJson = {\n                name: node.data.name,\n                appId: node.data.appId\n              }\n              // second.json\n              await Repo.writeFile('master', 'second.json', JSON.stringify(secondJson,null,2), 'initial setup commit', {\n                encode: true\n              });\n              // README\n              await Repo.writeFile('master', 'README.md', 'Repository for an app on Second', 'initial setup commit', {\n                encode: true\n              });\n              // \"nodes\" directory needs to exist?\n              await Repo.writeFile('master', 'nodes/.empty', '', 'initial setup commit', {\n                encode: true\n              });\n              \n              this.setState({\n                updatingGit: false\n              })\n              \n              \n              // Save updates to node \n              node.data.owner = owner;\n              node.data.repo = repo;\n              node.data.defaultBranch = defaultBranch;\n              \n              // Update editor \n              this.props.setEditState('data', JSON.stringify(node.data,null,2))\n              \n              let nodeToSave = {\n                _id: node._id,\n                data: node.data, // type should be correct! ,\n                updatedAt: (new Date()).getTime()\n              }\n              \n              console.log('Updating Node:', nodeToSave);\n              await this.makeSaveRequest(nodeToSave);\n              \n              // Save nodes immediately? \n              let saveNow = WINDOW.prompt('Save Nodes to Repo Now?', 'y');\n              if(!saveNow){\n                return false;\n              }\n              saveNow = (saveNow == 'y') ? true:false;\n              if(saveNow){\n                this.handleExportChildrenToGitHub(includeNode);\n              }\n              \n            }catch(err){\n              console.error('Failed github',err);\n            }\n            \n          });\n      \n        }\n        \n        @autobind\n        async handleExportChildrenToSharedNode(includeSelf){\n      \n          this.setState({\n            saving: true\n          })\n          \n          // let node = JSON.parse(JSON.stringify(this.props.node));\n          let baseNode = JSON.parse(JSON.stringify(this.props.editStateToObj()));\n          let sharedNodeId = baseNode.data.sharedNodeId;\n          let baseData;\n          let nodeToSave = null;\n          \n          console.log('all basenodes:', baseNode);\n          \n          function cleanNodes(nodes){\n          \tnodes.forEach(tmpNode=>{\n          \t\t// console.log(node);\n          \t\tdelete tmpNode._id;\n          \t\tdelete tmpNode.active;\n          \t\tdelete tmpNode.parent;\n          \t\tdelete tmpNode.nodeId;\n          \t\tdelete tmpNode.createdAt;\n          \t\tdelete tmpNode.updatedAt;\n              cleanNodes(tmpNode.nodes);\n          \n          \t})\n          }\n          cleanNodes([baseNode]);\n          \n          // shared_node already created? \n          // - updating? \n          if(sharedNodeId){\n            console.log('Updating SharedNode Code Package (todo)');\n            console.log('baseNode',baseNode);\n            console.log('id of shared_node', sharedNodeId);\n            \n            // remove sharedNodeId from shared_node \n            // - prevent shared_node pointing at an internal id\n            delete baseNode.data.sharedNodeId;\n            \n            // overwrite shared_node data (all of it) \n            nodeToSave = {\n              _id: sharedNodeId,\n              data: {\n                base: baseNode.data,\n                author: this.props.state.OwnerSecondExternalIdentityNode.data.identity, // \"idtest:nick\"\n                createdAt: Date.now(), // utc milliseconds since epoch \n                nodes: [baseNode] // includes app_base! \n              }\n            };\n            await this.makeSaveRequest(nodeToSave);  \n            \n          } else {\n            console.log('Creating New SharedNode Code Package');\n            \n            let sharedNode = {\n              type: 'app_package:Qm2389h32f',\n              data: {\n                base: baseNode.data,\n                author: this.props.state.OwnerSecondExternalIdentityNode.data.identity, // \"idtest:nick\"\n                createdAt: Date.now(), // utc milliseconds since epoch \n                nodes: [baseNode] // includes app_base! \n              }\n            }\n            \n            console.log('SharedNode:', sharedNode);\n            \n            // default to no access (root user had access) \n            let permissionsNode = {\n              type: 'syndication_permissions:Qmsdfkjsl2fj9vxc',\n              data: {\n                rules: []\n              }\n            };\n            \n            let syndicateToNode = {}; // done automatically, but could also provide a \"specifically syndicate this data somewhere\" node ? \n            \n            let saveSharedNode = await this.createSharedNodeOnSecond(sharedNode, permissionsNode, syndicateToNode);\n            \n            console.log('savedSharedNode',saveSharedNode);\n            \n            nodeToSave = baseNode;\n            delete nodeToSave.nodes; \n            nodeToSave.data.sharedNodeId = saveSharedNode._id;\n            \n            console.log('updating app_base with new sharedNodeId');\n            await this.makeSaveRequest(nodeToSave);  \n          \n          }\n          \n          \n          this.setState({\n            saving: false\n          })\n          \n          \n        }\n        \n        @autobind\n        createSharedNodeOnSecond(sharedNode, permissionsNode, syndicateToNode){\n          return new Promise(async (resolve, reject) => {\n            \n            console.log('NewNode:', sharedNode);\n                \n            // Make request to save Node on remote \n            try {\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          \n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                          \n                          {\n                            matchActionType: 'create_and_syndicate:Qmwlekjfwl',\n                            dataForAction: {\n                              type: 'create_and_syndicate_data:Qmskfjwoesjf',\n                              data: {\n                                sharedNode, // should include author=Second \n                                permissionsNode, // who can access this, get syndicated also \n                                syndicateToNode // where to syndicate this sharedNode  \n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('create_and_syndicate response:', response);\n              \n              // get the created node \n              let savedNode = response.data.actionResponses[1];\n              \n              // console.log('Saved Node:', savedNode);\n            \n              try {\n                universe.EE.emit('nodes-modified', '');\n              }catch(err){\n                console.error(err);\n              }\n              \n              return resolve(savedNode);\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              // alert('Failed');\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            }\n            \n          })\n        }\n      \n        @autobind\n        handleExportChildrenToGitHub(includeNode){\n        \n          // Export in \"name/file/directory\" format (no _ids) \n          // - file is name.json \n          // - nodes in directory /nodes/path_to_name  \n        \n          return new Promise(async (resolve,reject)=>{\n      \n            // let node = JSON.parse(JSON.stringify(this.props.node));\n            let node = JSON.parse(JSON.stringify(this.props.editStateToObj()));\n        \n            console.log('Node data (repo??)', node.data);\n        \n            let confirm;\n            confirm = WINDOW.confirm('Overwrite Nodes in github repo?');\n            if(!confirm){\n              return false;\n            }\n            \n            \n            let nodes;\n            if(includeNode){\n              nodes = [node];\n            } else {\n              nodes = node.nodes || [];\n            }\n            \n            \n            // remove nodeId from new \"root\" nodes \n            nodes = nodes.map(node=>{\n              delete node.nodeId;\n              return node;\n            })\n            \n            console.log('NODES:', nodes);\n            \n            let nodesToWrite = {};\n            \n            function handleNodes(path, nodes){\n            \n            \tnodes.forEach(tmpNode=>{\n            \t\t// console.log(node);\n            \t\tlet node = JSON.parse(JSON.stringify(tmpNode));\n                \n                let nodeToSave = {\n                  type: node.type,\n                  name: node.name,\n                  data: node.data,\n                }\n              \n                let nodePath = path.concat([node.name]);\n            \t\tnodesToWrite[nodePath.join('/') + '.json'] = JSON.stringify(nodeToSave,null,2);\n                \n            \t\tif(tmpNode.nodes && tmpNode.nodes.length){\n            \t\t\t// fs.mkdirSync('./nodes/');\t\n            \t\t\thandleNodes(nodePath, tmpNode.nodes)\n            \t\t}\n            \n            \t})\n            }\n            \n            handleNodes(['nodes'], nodes);\n            \n            \n            // actually write files to github\n            console.log('nodesToWrite:', nodesToWrite);\n            \n            let ghAuth = universe.localStorage.getItem('gh_auth') || '';\n            \n            console.log('ghAuth:', ghAuth);\n            \n            let ghUser;\n            let ghToken;\n            try {\n              if(!ghAuth){\n                ghUser = WINDOW.prompt('GitHub Username:', '');\n                ghToken = WINDOW.prompt('OAuth Token:', '');\n                if(!ghUser || !ghToken){\n                  return false;\n                }\n                ghAuth = [ghUser, ghToken].join(':');\n                universe.localStorage.setItem('gh_auth', ghAuth);\n              }\n              \n              ghUser = ghAuth.split(':')[0];\n              ghToken = ghAuth.split(':')[1];\n            }catch(err){\n              console.error('Failed ghAuth:', err);\n              return false;\n            }\n            \n            console.log('Setting state...', this, this.setState);\n            \n            this.setState({\n              updatingGit: 'Starting'\n            })\n            \n            // use pre-generated OAuth token for basic auth \n            try {\n              \n              console.log('Local Node Repo Info:', node.data);\n              \n              const gh = new universe.GitHub({\n                username: ghUser,\n                password: ghToken\n              });\n              \n              let Repo = gh.getRepo(node.data.owner, node.data.repo);\n              \n              console.log('Repo:', Repo);\n              \n              // Create a new Branch, not commit directory to master  \n              // - squash commits when merging!\n              let tmpBranch = 'tmp-' + (new Date()).getTime();\n              let createdBranch = await Repo.createBranch(node.data.defaultBranch, tmpBranch);\n              \n              console.log('createdBranch', createdBranch);\n              \n              let createdBranchSha = createdBranch.data.object.sha;\n              \n              // Get shas for files in directory (use getTree) \n              // let {data} = await Repo.getContents(tmpBranch, 'nodes/')\n              // // .then(({data})=>{\n              //   console.log('Got repo contents:', data);\n              // // })\n              \n              // let {data} = await Repo.getRef('heads/' + tmpBranch);\n              // console.log('Ref Data:', data);\n              \n              // let createdBranchTreeSha = data.object.sha;\n              \n              \n              let {data} = await Repo.getRef('heads/master');\n              console.log('Ref Data:', data);\n              \n              let masterRefSha = data.object.sha;\n              \n              // Get Tree for sha \n              // - using createdBranchSha (NOT masterRefSha) \n              let treeResult = await Repo.getTree(`${createdBranchSha}?recursive=true`);\n              console.log('treeResult', treeResult);\n              let treeData = treeResult.data;\n              let tree = treeData.tree;\n              \n              // Create new tree \n              // - including \"content\" instead of sha, expecting < 1 MB files (otherwise causes problems!)\n              let newTree = tree.filter(treeNode=>{\n                return (\n                  (treeNode.path.indexOf('nodes/') !== 0) \n                  && \n                  (treeNode.path.length > 6)\n                )\n              })\n              \n              // iterate over new files, see if old exists (and if SHA needs to be updated) \n              // - will ignore/handle deleted or moved files \n              let ghFilesByPath = {};\n              let changes = 1;\n              for(let node of tree){\n                \n                // let nodeFolder = node.path.slice(0,node.path.length - 5);\n                // console.log('nodeFolder', nodeFolder);\n                \n                ghFilesByPath[node.path] = node;\n              }\n              for(let path of Object.keys(nodesToWrite)){\n                let ghNode = ghFilesByPath[path];\n                let newSha;\n                if(ghNode){\n                  // exists, update necessary? \n                  \n                  // sha1(\"blob \" + filesize + \"\\0\" + data)\n                  newSha = universe.SHA1(\"blob \" + nodesToWrite[path].length + \"\\0\" + nodesToWrite[path]).toString();\n                  \n                  if(newSha == ghNode.sha){\n                    console.log('No Change:', path);\n                    newTree.push(ghNode);\n                  } else {\n                    console.log('Updated:', path, newSha, ghNode.sha);\n                    changes++;\n                    // delete first, so that squashed merge works later! \n                    \n                    this.setState({\n                      updatingGit: 'Updating ' + path\n                    })\n                    \n                    newTree.push({\n                      path: path,\n                      type: 'blob', // tree\n                      mode: '100644', // 040000\n                      content: nodesToWrite[path]\n                    });\n                    \n                    // await Repo.deleteFile(tmpBranch, path);\n                    // await Repo.writeFile(tmpBranch, path, nodesToWrite[path], 'commit message', {\n                    //   encode: true\n                    // });\n                    \n                  }\n                } else {\n                  // doesn't exist \n                  // - needs to be added \n                  console.log('New');\n                  \n                  // sha1(\"blob \" + filesize + \"\\0\" + data)\n                  // newSha = universe.SHA1(\"blob \" + nodesToWrite[path].length + \"\\0\" + nodesToWrite[path]).toString();\n                  \n                  newTree.push({\n                    path: path,\n                    type: 'blob', // tree\n                    mode: '100644', // 040000\n                    content: nodesToWrite[path]\n                  });\n                  \n                }\n              }\n              \n              \n              let createdTree = await Repo.createTree(newTree); // include \"treeData.sha\" as second parameter to not delete any files? \n              console.log('CreatedTree:', createdTree);\n              \n              let newTreeSha = createdTree.data.sha;\n              \n              // Create a new commit to temporary branch \n              let newCommit = await Repo.commit(createdBranchSha, newTreeSha, 'test-tree-commit');\n              \n              console.log('newCommit', newCommit);\n              \n              let newCommitSha = newCommit.data.sha;\n              \n              // Update HEAD of branch \n              console.log('Update HEAD of tmp branch?');\n              await Repo.updateHead('heads/' + tmpBranch, newCommitSha);\n                \n              // let treeNodes = tree.filter(treeNode=>{\n              //   // must be on \"nodes\" path, \n              //   // - only type=blob\n              //   let path = treeNode.path;\n              //   if(path.indexOf('nodes/') === 0 && treeNode.type == 'blob'){\n              //     return true;\n              //   }\n              //   return false;\n              // });\n              \n              // console.log('TreeNodes:', treeNodes);\n              \n              // // check nodes in github \n              // // - missing nodes should be deleted \n              // let changes = 0;\n              // let toRemove = [];\n              // // let ghFilesByPath = {};\n              // let removedParentPaths = [];\n              // for(let node of treeNodes){\n                \n              //   let nodeFolder = node.path.slice(0,node.path.length - 5);\n              //   console.log('nodeFolder', nodeFolder, removedParentPaths);\n                \n              //   ghFilesByPath[node.path] = node;\n              //   if(!nodesToWrite[ node.path ]){\n              //     // missing, nodes should be removed\n              //     // toRemove.push(node.path); // \"path\" includes \"nodes/\"...\n              //     console.log('Removing1:', node.path);\n              //     changes++;\n                    \n              //     this.setState({\n              //       updatingGit: 'Removing ' + node.path\n              //     })\n                  \n              //     // may fail, especially if parent node is moved/renamed?\n              //     try {\n              //       let parentRemoved;\n              //       removedParentPaths.forEach(parentPath=>{\n              //         if(nodeFolder.indexOf(parentPath) === 0){\n              //           parentRemoved = true;\n              //         }\n              //       })\n              //       if(parentRemoved){\n              //         // parent path already removed \n              //         console.log('parent path already removed');\n              //       } else {\n                      \n              //         console.log('Removing file/path:', nodeFolder, removedParentPaths);\n              //         removedParentPaths.push( nodeFolder );\n                      \n              //         await Repo.deleteFile(tmpBranch, node.path);\n              //         // delete directory too (nodes)  (- \".json')\n              //         await Repo.deleteFile(tmpBranch, nodeFolder);\n                      \n              //       }\n              //     }catch(err){\n              //       console.error('Failed delete:', err);\n              //     }\n                      \n                  \n              //   }\n              // }\n              \n              // console.log('ghFilesByPath', ghFilesByPath);\n              \n              // // check nodes locally\n              // // - some nodes should be updated \n              // // - some nodes will be new \n              // for(let path of Object.keys(nodesToWrite)){\n              //   if(ghFilesByPath[path]){\n              //     // exists, update necessary? \n                  \n              //     // sha1(\"blob \" + filesize + \"\\0\" + data)\n              //     let newSha = universe.SHA1(\"blob \" + nodesToWrite[path].length + \"\\0\" + nodesToWrite[path]).toString();\n                  \n              //     if(newSha == ghFilesByPath[path].sha){\n              //       console.log('No Change:', path);\n              //     } else {\n              //       console.log('Updated:', path, newSha, ghFilesByPath[path].sha);\n              //       changes++;\n              //       // delete first, so that squashed merge works later! \n                    \n              //       this.setState({\n              //         updatingGit: 'Updating ' + path\n              //       })\n                    \n              //       await Repo.deleteFile(tmpBranch, path);\n              //       await Repo.writeFile(tmpBranch, path, nodesToWrite[path], 'commit message', {\n              //         encode: true\n              //       });\n                      \n                    \n              //     }\n              //   } else {\n              //     // doesnt exist, write new! \n              //     console.log('New', path);\n              //     changes++;\n                  \n              //     this.setState({\n              //       updatingGit: 'Adding ' + path\n              //     })\n                  \n              //     await Repo.writeFile(tmpBranch, path, nodesToWrite[path], 'commit message', {\n              //       encode: true\n              //     });\n                  \n              //   }\n              // }\n              \n              // console.log('WRITING');\n              // await Repo.writeFile(tmpBranch, 'nodes/test.json1', '{}', 'commit message', {\n              //   encode: true\n              // });\n              \n              if(changes || 1==1){\n              \n                this.setState({\n                  updatingGit: 'Create Temp PR'\n                })\n                \n                let pr;\n                try {\n                  pr = await Repo.createPullRequest({\n                    title: 'Temporary Pull Request, should auto-remove in moments',\n                    head: [node.data.owner, tmpBranch].join(':'),\n                    base: node.data.defaultBranch\n                  });\n                }catch(err){\n                  console.error('Failed creating PR:', err);\n                  this.setState({\n                    updatingGit: false\n                  })\n                  return WINDOW.alert('Failed creating PR, likely no changes');\n                }\n                \n                console.log('PR:', pr);\n                \n                console.log('PR Number:', pr.data.number);\n                \n                this.setState({\n                  updatingGit: 'Merge Temp PR'\n                })\n                \n                let merged;\n                try {\n                  merged = await Repo.mergePullRequest(pr.data.number, {\n                    commit_title: 'squashed merge title',\n                    commit_message: 'squashed merge message',\n                    merge_method: 'squash'\n                  });\n                }catch(err){\n                  console.error('Failed merging PR:', err);\n                  this.setState({\n                    updatingGit: false\n                  })\n                  return WINDOW.alert('Failed merging PR. Please try again');\n                }\n                \n                console.log('merged', merged);\n              } else {\n                // no PR necessary, no changes made! \n              }\n              \n              this.setState({\n                updatingGit: 'Remove Branch'\n              })\n              \n              // delete tmp branch (remove reference?)  \n              await Repo.deleteRef(`heads/${tmpBranch}`);\n              \n              // if(changes){\n              //   WINDOW.alert('Changes made: ' + changes);\n              // } else {\n              //   WINDOW.alert('No Changes to Make!');\n              // }\n              \n              this.setState({\n                updatingGit: false\n              })\n              \n              console.log('Done, cleaned up tmpBranch!');\n              \n              \n            }catch(err){\n              console.error('Failed github',err);\n            }\n            \n          });\n      \n        }\n      \n        @autobind\n        handleExportChildrenToGitHub_ORIGINAL(includeNode){\n      \n          return new Promise(async (resolve,reject)=>{\n      \n            // let node = JSON.parse(JSON.stringify(this.props.node));\n            let node = JSON.parse(JSON.stringify(this.props.editStateToObj()));\n        \n            console.log('Node data (repo??)', node.data);\n        \n            let confirm;\n            confirm = WINDOW.confirm('Overwrite Nodes in github repo?');\n            if(!confirm){\n              return false;\n            }\n            \n            \n            let nodes;\n            if(includeNode){\n              nodes = [node];\n            } else {\n              nodes = node.nodes || [];\n            }\n            \n            \n            // remove nodeId from new \"root\" nodes \n            nodes = nodes.map(node=>{\n              delete node.nodeId;\n              return node;\n            })\n            \n            console.log('NODES:', nodes);\n            \n            let nodesToWrite = {};\n            \n            function handleNodes(nodes){\n            \n            \tnodes.forEach(tmpNode=>{\n            \t\t// console.log(node);\n            \t\tlet node = JSON.parse(JSON.stringify(tmpNode));\n            \n            \t\tdelete node.parent;\n            \t\tdelete node.nodes;\n            \n            \t\tnodesToWrite[node._id + '.json'] = JSON.stringify(node,null,2);\n            \n            \t\tif(tmpNode.nodes && tmpNode.nodes.length){\n            \t\t\t// fs.mkdirSync('./nodes/');\t\n            \t\t\thandleNodes(tmpNode.nodes)\n            \t\t}\n            \n            \t})\n            }\n            \n            handleNodes(nodes);\n            \n            \n            // actually write files to github\n            console.log('nodesToWrite:', nodesToWrite);\n            \n            let ghAuth = universe.localStorage.getItem('gh_auth') || '';\n            \n            console.log('ghAuth:', ghAuth);\n            \n            let ghUser;\n            let ghToken;\n            try {\n              if(!ghAuth){\n                ghUser = WINDOW.prompt('GitHub Username:', '');\n                ghToken = WINDOW.prompt('OAuth Token:', '');\n                if(!ghUser || !ghToken){\n                  return false;\n                }\n                ghAuth = [ghUser, ghToken].join(':');\n                universe.localStorage.setItem('gh_auth', ghAuth);\n              }\n              \n              ghUser = ghAuth.split(':')[0];\n              ghToken = ghAuth.split(':')[1];\n            }catch(err){\n              console.error('Failed ghAuth:', err);\n              return false;\n            }\n            \n            console.log('Setting state...', this, this.setState);\n            \n            this.setState({\n              updatingGit: 'Starting'\n            })\n            \n            // use pre-generated OAuth token for basic auth \n            try {\n              \n              console.log('Local Node Repo Info:', node.data);\n              \n              const gh = new universe.GitHub({\n                username: ghUser,\n                password: ghToken\n              });\n              \n              let Repo = gh.getRepo(node.data.owner, node.data.repo);\n              \n              console.log('Repo:', Repo);\n              \n              // Create a new Branch, not commit directory to master  \n              // - squash commits when merging!\n              let tmpBranch = 'tmp-' + (new Date()).getTime();\n              await Repo.createBranch(node.data.defaultBranch, tmpBranch);\n              \n              // Get shas for files in directory (use getContents) \n              let {data} = await Repo.getContents(tmpBranch, 'nodes/')\n              // .then(({data})=>{\n                console.log('Got repo contents:', data);\n              // })\n              \n              \n              // check nodes in github \n              // - missing nodes should be deleted \n              let changes = 0;\n              let toRemove = [];\n              let ghFilesByName = {};\n              for(let node of data){\n                ghFilesByName[node.name] = node;\n                if(!nodesToWrite[ node.name ]){\n                  // missing, nodes should be removed\n                  // toRemove.push(node.path); // \"path\" includes \"nodes/\"...\n                  console.log('Removing:', node.name);\n                  changes++;\n                    \n                  this.setState({\n                    updatingGit: 'Removing ' + node.name\n                  })\n                  \n                  await Repo.deleteFile(tmpBranch, node.path);\n                      \n                  \n                }\n              }\n              \n              // check nodes locally\n              // - some nodes should be updated \n              // - some nodes will be new \n              for(let name of Object.keys(nodesToWrite)){\n                if(ghFilesByName[name]){\n                  // exists, update necessary? \n                  \n                  // sha1(\"blob \" + filesize + \"\\0\" + data)\n                  let newSha = universe.SHA1(\"blob \" + nodesToWrite[name].length + \"\\0\" + nodesToWrite[name]).toString();\n                  \n                  if(newSha == ghFilesByName[name].sha){\n                    console.log('No Change:', name);\n                  } else {\n                    console.log('Updated:', name, newSha, ghFilesByName[name].sha);\n                    changes++;\n                    // delete first, so that squashed merge works later! \n                    \n                    this.setState({\n                      updatingGit: 'Updating ' + name\n                    })\n                    \n                    await Repo.deleteFile(tmpBranch, 'nodes/' + name);\n                    await Repo.writeFile(tmpBranch, 'nodes/' + name, nodesToWrite[name], 'commit message', {\n                      encode: true\n                    });\n                      \n                    \n                  }\n                } else {\n                  // doesnt exist, write new! \n                  console.log('New', name);\n                  changes++;\n                  \n                  this.setState({\n                    updatingGit: 'Adding ' + name\n                  })\n                  \n                  await Repo.writeFile(tmpBranch, 'nodes/' + name, nodesToWrite[name], 'commit message', {\n                    encode: true\n                  });\n                  \n                }\n              }\n              \n              // console.log('WRITING');\n              // await Repo.writeFile(tmpBranch, 'nodes/test.json1', '{}', 'commit message', {\n              //   encode: true\n              // });\n              \n              if(changes){\n              \n                this.setState({\n                  updatingGit: 'Create Temp PR'\n                })\n                \n                let pr = await Repo.createPullRequest({\n                  title: 'Temporary Pull Request, should auto-remove in moments',\n                  head: [node.data.owner, tmpBranch].join(':'),\n                  base: node.data.defaultBranch\n                });\n                \n                console.log('PR:', pr);\n                \n                console.log('PR Number:', pr.data.number);\n                \n                this.setState({\n                  updatingGit: 'Merge Temp PR'\n                })\n                \n                let merged = await Repo.mergePullRequest(pr.data.number, {\n                  commit_title: 'squashed merge title',\n                  commit_message: 'squashed merge message',\n                  merge_method: 'squash'\n                });\n                \n                console.log('merged', merged);\n              } else {\n                // no PR necessary, no changes made! \n              }\n              \n              this.setState({\n                updatingGit: 'Remove Branch'\n              })\n              \n              // delete tmp branch (remove reference?)  \n              await Repo.deleteRef(`heads/${tmpBranch}`);\n              \n              if(changes){\n                WINDOW.alert('Changes made: ' + changes);\n              } else {\n                WINDOW.alert('No Changes to Make!');\n              }\n              \n              this.setState({\n                updatingGit: false\n              })\n              \n              console.log('Done, cleaned up tmpBranch!');\n              \n              \n            }catch(err){\n              console.error('Failed github',err);\n            }\n            \n          });\n      \n        }\n        \n        @autobind\n        handleClearGitHubCredentials(){\n          universe.localStorage.removeItem('gh_auth');\n          WINDOW.alert('Credentials cleared');\n        }\n      \n        @autobind\n        handleGetLatestCodeNode(){\n          return new Promise(async (resolve,reject)=>{\n            // gets NodeChain ref's matching node.data.internalId\n            // - useful for checking if a CodeNode has an update (or exists?)? \n            \n            console.log('Updating with latest code! TODO');  \n            \n          });\n        }\n      \n        @autobind\n        handleChangeNodeChainData(){\n          \n          return new Promise(async (resolve,reject)=>{\n            \n            console.log('handleChangeNodeChainData');\n            \n            // whole object\n            let node = this.props.editStateToObj();\n          \n            let nodeChains = this.state.nodeChains;\n            if(!nodeChains){\n              nodeChains = await this.fetchNodeChains();\n            }\n            let chainOptions = \"Choose Chain:\\n\" + nodeChains.map((n,i)=>{\n              return [i+1,'. ', n.data.username].join('')\n            }).join(\"\\n\");\n            let chosenChain = WINDOW.prompt(chainOptions,'1');\n            if(!chosenChain){\n              this.setState({\n                isPublishing: false\n              })\n              return false;\n            }\n            \n            let tmpNodeChainInfo = nodeChains[parseInt(chosenChain,10)-1];\n            \n            console.log('chosenChain', chosenChain, '(subtract 1)', nodeChains, tmpNodeChainInfo);\n            \n            if(!tmpNodeChainInfo){\n              WINDOW.alert('INVALID nodechain specified');\n              this.setState({\n                isPublishing: false\n              })\n              return false;\n            }\n            \n            // strip extra from node (_id, createdAt, etc.) \n            let nodeChainInfo = JSON.parse(JSON.stringify(tmpNodeChainInfo));\n            node.data.nodeChainNode = {\n              type: nodeChainInfo.type,\n              data: nodeChainInfo.data,\n            }\n          \n            // update on remote second\n            let nodeToSave = {\n              _id: node._id,\n              data: node.data, // type should be correct! ,\n              updatedAt: (new Date()).getTime()\n            }\n            \n            console.log('Updating Node:', nodeToSave);\n            await this.makeSaveRequest(nodeToSave);\n            \n        \n            // update whole Node \n            // - easier than updating individual parts for now\n            this.refetchNode();\n            \n            \n          });\n      \n        }\n      \n        @autobind\n        handleExportToNodeChain(){\n          \n          return new Promise(async (resolve,reject)=>{\n            \n            console.log('handleExportToNodeChain');\n            \n            // whole object\n            let node = this.props.editStateToObj();\n          \n            console.log('Node For Chain:', node);\n        \n            // let node = JSON.parse(JSON.stringify(this.props.node));\n            let ref = node.data.key;\n            let version = (node.data.version || 1).toString();\n            let author = node.data.author;\n            \n            let nodeChainInfo = node.data.nodeChainNode;\n            \n            if(!ref){\n              return WINDOW.alert('Missing key (uuid) for node. Required for publishing new node (used for \"ref\")');\n            }\n            \n            this.setState({\n              isPublishing: true\n            })\n            \n            // Determine the NodeChain we are publishing to \n            let updateNodeWithNodeChain = false;\n            if(!nodeChainInfo){\n              // Missing, prompt for the nodechain to use \n              // - choose from an existing NodeChain in cloud Second memory \n              \n              let nodeChains = this.state.nodeChains;\n              if(!nodeChains){\n                nodeChains = await this.fetchNodeChains();\n              }\n              let chainOptions = \"Choose Chain:\\n\" + nodeChains.map((n,i)=>{\n                return [i+1,'. ', n.data.username].join('')\n              }).join(\"\\n\");\n              let chosenChain = WINDOW.prompt(chainOptions,'1');\n              if(!chosenChain){\n                this.setState({\n                  isPublishing: false\n                })\n                return false;\n              }\n              \n              nodeChainInfo = nodeChains[parseInt(chosenChain,10)-1];\n              \n              console.log('chosenChain', chosenChain, '(subtract 1)', nodeChains, nodeChainInfo);\n              \n              if(!nodeChainInfo){\n                WINDOW.alert('INVALID nodechain specified');\n                this.setState({\n                  isPublishing: false\n                })\n                return false;\n              }\n              \n              // Update the node also! \n              updateNodeWithNodeChain = true;\n              node.data.nodeChainNode = JSON.parse(JSON.stringify(nodeChainInfo));\n              \n              // remove the \"privateKey\" if exists\n              delete node.data.nodeChainNode.data.privateKey;\n              \n            }\n            \n            \n            \n            // When clicked: \n            // - may or may not be already in teaching_sources \n            // - I'm probably not the owner at first (but I want to start my own version of the Node) \n            \n            // Make sure my private key is stored for publishing to NodeChain \n            // - TODO: use my Second's private key for writing! \n            let nodeChainPrivateKey = universe.localStorage.getItem('nodechain_private_key') || '';\n            if(!nodeChainPrivateKey.length){\n              nodeChainPrivateKey = WINDOW.prompt('Private Key for Publishing (base64)','');\n              if(!nodeChainPrivateKey){\n                return false;\n              }\n              nodeChainPrivateKey = atob(nodeChainPrivateKey);\n              universe.localStorage.setItem('nodechain_private_key', nodeChainPrivateKey);\n            }\n            \n            let publishKey = new universe.rsa(nodeChainPrivateKey);\n            let publishPublicKey = publishKey.exportKey('public');\n            \n            console.log('My Publishing PublicKey:', publishPublicKey);\n            \n            // Get code node for key + publicKey \n            // - will get latest version \n            // - we will increment that version (assuming an integer-as-string for version) \n            \n            let latestCodeNode = this.state.latestNode;\n            // universe.lodash.sortBy(this.state.chainNodes,n=>{\n            //   return parseInt(n.version, 10)\n            // });\n            // if(!latestCodeNode.length){\n            //   latestCodeNode = null;\n            // }\n            // if(latestCodeNode && latestCodeNode.length){\n            //   latestCodeNode = latestCodeNode[latestCodeNode.length - 1];\n            // }\n            \n            \n            if(publishPublicKey == node.data.author){\n              // I'm updating my own node \n              // - update version number \n              console.log('Updating my own node');\n              \n              if(!latestCodeNode){\n                console.log('trying to update without existing');\n                WINDOW.alert('trying to update without existing on chain (error fetching?)');\n                \n                this.setState({\n                  isPublishing: false\n                })\n                return false;\n              }\n              \n              version = ((parseInt(latestCodeNode.version, 10) || 0) + 1).toString()\n              \n              console.log('New Version:', version);\n              \n            \n              // publish code to NodeChain \n              console.log('Publish code node to NodeChain');\n              let newChainNode = await universe.publishToNodeChain({\n                apiAddress: nodeChainInfo.data.apiAddress,\n                nodeInputStr: JSON.stringify({\n                  type: node.type,\n                  data: {\n                    key: ref,\n                    internalId: node.data.internalId,\n                    code: node.data.code,\n                    note: node.data.note,\n                    version\n                  }\n                }),\n                privateKey: nodeChainPrivateKey,\n                chainPubKey: nodeChainInfo.data.pubKey,\n                // chainPubKey: atob('LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUlHZk1BMEdDU3FHU0liM0RRRUJBUVVBQTRHTkFEQ0JpUUtCZ1FDQk5uRkMya1Z5bllDZGg0NDFOeEZxQjJUVgpLVFlaUFBaZ01mU2RxcmRDT0FGcTNnMFcyVG12U3pTMnFZNDNEVjgwdHB6ekVOaTRibk9rT1VGVmw5WGk1NTNDCisraGRucWcrcEFHYlQ5UDNDcjdyNkNOMVpOQlB4OEpYbnlXTmZ4ek5oaStyQ21hMUVwWmFvUkhiVnhUWDE3MFYKVzJxeW95Wkk4cUc5cnNxQjdRSURBUUFCCi0tLS0tRU5EIFBVQkxJQyBLRVktLS0tLQ=='),\n                ref,\n                version,\n                nonce: universe.uuidv4()\n              });\n              \n              // Update the \"local\" (remote Second) node as well \n              // - updated version, author, etc. \n      \n              console.log('New Chain Node (code update):', newChainNode);\n              \n              if(newChainNode.error){\n                return WINDOW.alert('Error publishing');\n              }\n              if(!newChainNode.node){\n                return WINDOW.alert('Error publishing2');\n              }\n              \n              node.data.version = version;\n              // node.data.author = author; // already correct\n              \n              // update on remote second\n              let nodeToSave = {\n                _id: node._id,\n                data: node.data, // type should be correct! ,\n                updatedAt: (new Date()).getTime()\n              }\n              \n              console.log('Updating Node:', nodeToSave);\n              await this.makeSaveRequest(nodeToSave);\n              \n            \n              // update whole Node \n              // - easier than updating individual parts for now\n              this.refetchNode();\n              \n              \n            } else {\n              \n              // publishPublickKey != node.data.author\n              \n              // I'm creating my own code-node-version from someone else's node (or a blank node) \n              // - I need to update the publicKey to be my own \n              //  - add the \"branched at\" information in case I want to go backwards (TODO) \n              console.log('Creating new code node or updating someone elses code node');\n              \n              if(latestCodeNode){\n                // found existing ref+author match (i'm actualy forking, not creating an entirely new one) \n                WINDOW.alert('Unable to fork yet');\n                \n                this.setState({\n                  isPublishing: false\n                })\n                return false;\n                \n              } else {\n                // not able to find any existing code with matching reference and author \n                // - aka \"totally new\" \n                \n                console.log('totally new code node (no ref+author)');\n                \n                author = publishPublicKey;\n                version = '1';\n                \n                if(!WINDOW.confirm('Create new Node? (no existing ref+author found)')){\n                  this.setState({\n                    isPublishing: false\n                  })\n                  return false;\n                }\n                \n                // publish code to NodeChain \n                console.log('Publish code node to NodeChain');\n                let newChainNode = await universe.publishToNodeChain({\n                  apiAddress: nodeChainInfo.data.apiAddress,\n                  nodeInputStr: JSON.stringify({\n                    type: node.type,\n                    data: {\n                      key: ref,\n                      internalId: node.data.internalId,\n                      code: node.data.code,\n                      note: node.data.note,\n                      version\n                    }\n                  }),\n                  privateKey: nodeChainPrivateKey,\n                  chainPubKey: nodeChainInfo.data.pubKey,\n                  // chainPubKey: atob('LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUlHZk1BMEdDU3FHU0liM0RRRUJBUVVBQTRHTkFEQ0JpUUtCZ1FDQk5uRkMya1Z5bllDZGg0NDFOeEZxQjJUVgpLVFlaUFBaZ01mU2RxcmRDT0FGcTNnMFcyVG12U3pTMnFZNDNEVjgwdHB6ekVOaTRibk9rT1VGVmw5WGk1NTNDCisraGRucWcrcEFHYlQ5UDNDcjdyNkNOMVpOQlB4OEpYbnlXTmZ4ek5oaStyQ21hMUVwWmFvUkhiVnhUWDE3MFYKVzJxeW95Wkk4cUc5cnNxQjdRSURBUUFCCi0tLS0tRU5EIFBVQkxJQyBLRVktLS0tLQ=='),\n                  ref,\n                  version,\n                  nonce: universe.uuidv4()\n                });\n                \n                // Update the \"local\" (remote Second) node as well \n                // - updated version, author, etc. \n        \n                console.log('New Chain Node:', newChainNode);\n                \n                if(newChainNode.error){\n                  return WINDOW.alert('Error publishing');\n                }\n                if(!newChainNode.node){\n                  return WINDOW.alert('Error publishing2');\n                }\n                \n                node.data.version = version;\n                node.data.author = author;\n                \n                // update on server\n                let nodeToSave = {\n                  _id: node._id,\n                  data: node.data, // type should be correct! ,\n                  updatedAt: (new Date()).getTime()\n                }\n                \n                console.log('Updating Node:', nodeToSave);\n                await this.makeSaveRequest(nodeToSave);\n                \n              }\n            \n              // update whole Node \n              // - easier than updating individual parts for now\n              this.refetchNode();\n            \n              this.setState({\n                isPublishing: false\n              })\n              \n            }\n            \n            \n            \n            // Got a code node from remote? \n            // - if yes, update version automatically and approve \n            // - if no, create a new one \n            \n            \n            \n            // Update the local CodeNode (with new version, etc.) \n            \n            \n            // Will create a new one if necessary \n            // - only available if node's Parent is folder:teaching_sources\n            \n            \n          });\n      \n        }\n        \n        @autobind\n        fetchNodeChains(){\n          \n          // \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n              \n              this.setState({\n                // fetchingRemote: true\n              })\n              \n              // let ExternalIdentityNodes = await universe.searchMemory({\n              //   filter: {\n              //     sqlFilter: {\n              //       type: 'external_identity:0.0.1:local:8982f982j92',\n              //       data: {\n              //         commonName: 'main'\n              //       }\n              //     }\n              //   }\n              // });\n              // let ExternalIdentityNode = ExternalIdentityNodes[0];\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode, \n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                          {\n                            matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                            dataForAction: {\n                              type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              data: {\n                                matchFunctionNode: {\n                                  // query here!\n                                  // action_pointer:0.0.1:local:238972ncr\n                                  type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                  data: {\n                                    code: `(()=>{\n                                      // Action \n                                      // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                      \n                                      let inputNode = INPUT.data.inputNode;\n                                      \n                                      if(inputNode.nodeId){\n                                        return false;\n                                      }\n                                      \n                                      if(inputNode.type.split(':')[0] != 'node_chain_info'){\n                                        return null;\n                                      }\n                                      \n                                      // if(inputNode.data.learn != 'browser_developer'){\n                                      //   return null;\n                                      // }\n                                      \n                                      // // strip childnodes\n                                      // // delete inputNode.nodes; \n                                      // // delete inputNode.parent;\n                                      // delete inputNode.data;\n              \n                                      return inputNode;\n                                      \n                                    })()`\n                                  }\n                                },\n                                \n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              let nodes = response.data.actionResponses[1].data;\n              \n              // let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                nodeChains: nodes,\n                // fetchingRemote: false\n              })\n              \n              return resolve(nodes);\n              \n              \n            } catch(err){\n              console.error('Failed getting node_chain_info nodes');\n              \n              this.setState({\n                // fetchingRemote: false\n              })\n              \n              \n              return reject();\n              \n            }\n            \n          });\n          \n        }\n      \n        @autobind\n        handleDelete(){\n      \n          return new Promise(async (resolve,reject)=>{\n      \n            let node = JSON.parse(JSON.stringify(this.props.node));\n      \n            // Create this new one, then iterate down the tree of kids \n            // - if this one has a nodeId, ask if we want to keep it? \n            let confirmed = WINDOW.prompt('Delete for sure?','y');\n            if(confirmed != 'y'){\n              return false;\n            }\n      \n            this.setState({\n              saving: true\n            });\n            \n            node.active = false;\n            let deleted = await this.makeSaveRequest({\n              _id: node._id,\n              active: false\n            }, {\n              skipWaitForResolution: true, \n              skipRebuild: true\n            }, true);\n            \n            const deleteChildNodes = (childNodes) => {\n              return new Promise(async (resolve, reject)=>{\n                \n                for(let tmpNode of childNodes){\n      \n                  // let deletedChildNode = await this.makeDelete(tmpNode);\n                  tmpNode.active = false;\n                  let deletedChildNode = await this.makeSaveRequest({\n                    _id: tmpNode._id,\n                    active: false\n                  }, {\n                    skipWaitForResolution: true, \n                    skipRebuild: true\n                  }, true);\n      \n                  if(tmpNode.nodes && tmpNode.nodes.length){\n                    await deleteChildNodes(tmpNode.nodes);\n                  }\n                }\n                resolve();\n      \n              });\n            }\n      \n            // if(node.nodes){\n            //   await deleteChildNodes(node.nodes);\n            // }\n      \n            console.log('rebuilding memory on remote, after bulk updates');\n            await this.makeRebuildMemoryRequest();\n            \n            this.setState({\n              saving: false\n            });\n        \n            console.log('Done Deleting (and children)');\n          \n            try {\n              universe.EE.emit('nodes-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n            this.props.setState({\n              editingNode: null\n            })\n            // window.location = '/node';\n      \n          });\n      \n        }\n      \n        @autobind\n        handleDeleteChildren(){\n      \n          return new Promise(async (resolve,reject)=>{\n      \n            let node = JSON.parse(JSON.stringify(this.props.node));\n      \n            // Create this new one, then iterate down the tree of kids \n            // - if this one has a nodeId, ask if we want to keep it? \n            let confirmed = WINDOW.prompt(`Delete ${node.nodes.length} child nodes for sure?`,'y');\n            if(confirmed != 'y'){\n              return false;\n            }\n      \n            this.setState({\n              saving: true\n            });\n            \n            // node.active = false;\n            // let deleted = await this.makeSaveRequest({\n            //   _id: node._id,\n            //   active: false\n            // }, true);\n            \n            const deleteChildNodes = (childNodes) => {\n              return new Promise(async (resolve, reject)=>{\n                \n                for(let tmpNode of childNodes){\n      \n                  // let deletedChildNode = await this.makeDelete(tmpNode);\n                  tmpNode.active = false;\n                  let deletedChildNode = await this.makeSaveRequest({\n                    _id: tmpNode._id,\n                    active: false\n                  }, {\n                    skipWaitForResolution: true, \n                    skipRebuild: true\n                  }, true);\n      \n                  if(tmpNode.nodes && tmpNode.nodes.length){\n                    await deleteChildNodes(tmpNode.nodes);\n                  }\n                }\n                resolve();\n      \n              });\n            }\n      \n            if(node.nodes){\n              await deleteChildNodes(node.nodes);\n            }\n      \n            console.log('rebuilding memory on remote, after bulk updates');\n            await this.makeRebuildMemoryRequest();\n            \n            this.setState({\n              saving: false\n            });\n        \n            console.log('Done Deleting (and children)');\n          \n            try {\n              universe.EE.emit('nodes-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n      \n          });\n      \n        }\n        \n        @autobind\n        makeSaveRequest(nodeToSave, opts, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            this.setState({\n              saving: true\n            })\n            \n            opts = opts || {};\n            \n            // Make request to save Node on remote \n            try {\n              \n              // let ExternalIdentityNodes = await universe.searchMemory({\n              //   filter: {\n              //     sqlFilter: {\n              //       type: 'external_identity:0.0.1:local:8982f982j92',\n              //       data: {\n              //         commonName: 'main'\n              //       }\n              //     }\n              //   }\n              // });\n              // let ExternalIdentityNode = ExternalIdentityNodes[0];\n              \n              // let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n              //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n              //   data: {\n              //     action: 'send',\n              //     options: {\n              //       ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n              //       RequestNode: {\n              //         type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n              //         data: {\n              //           actions: [\n              //             {\n              //               matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n              //               dataForAction: {\n              //                 type: 'string:...',\n              //                 data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n              //               }\n              //             },\n              //             {\n              //               matchActionType: 'update_node:0.0.2:local:392821982y3',\n              //               dataForAction: {\n              //                 type: 'update_node_data:0.0.2:local:123445',\n              //                 data: {\n              //                   optionsNode: {\n              //                     type: 'options_generic:0.0.1:local:289f3j29832',\n              //                     data: opts || {}\n              //                   },\n              //                   dataNode: nodeToSave\n              //                 }\n              //               }\n              //             }\n              //           ]\n                        \n              //         }\n              //       }\n              //     }\n              //   }\n              // });\n              \n              // console.log('Update response:', response);\n              \n              let response = await universe.$.ajax({\n                url: '/api/put',\n                method: 'post',\n                contentType: 'application/json',\n                data: JSON.stringify(nodeToSave)\n              });\n              \n              if(skipEvent !== true){\n                try {\n                  universe.EE.emit('nodes-modified', '');\n                }catch(err){\n                  console.error(err);\n                }\n              }\n              \n              this.setState({\n                saving: false\n              })\n              \n              return resolve({\n                type: 'node:...',\n                data: response\n              });\n              \n            } catch(err){\n              console.error('Failed saving');\n              \n              WINDOW.alert('Failed saving');\n              \n              this.setState({\n                saving: false\n              })\n              \n              return reject();\n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        makeRebuildMemoryRequest(){\n          return new Promise(async (resolve, reject) => {\n            \n            try {\n              \n              // let ExternalIdentityNodes = await universe.searchMemory({\n              //   filter: {\n              //     sqlFilter: {\n              //       type: 'external_identity:0.0.1:local:8982f982j92',\n              //       data: {\n              //         commonName: 'main'\n              //       }\n              //     }\n              //   }\n              // });\n              // let ExternalIdentityNode = ExternalIdentityNodes[0];\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                          {\n                            matchActionType: 'rebuild_memory:Qmdsf892hf98h23',\n                            dataForAction: {\n                              type: 'rebuild_memory:0.0.2:local:123445',\n                              data: {\n                                skipWaitForResolution: false\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              \n              return resolve({\n                type: 'boolean:...',\n                data: true\n              });\n              \n            } catch(err){\n              console.error('Failed rebuildMemory');\n              \n              alert('Failed rebuildMemory');\n              \n              return reject();\n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        forcePutNode(path, nodeToSave, opts, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            console.log('NewNode:', path, nodeToSave);\n            \n            // Make request to save Node on remote \n            try {\n              \n              universe.$.ajax({\n                url: '/api/put',\n                method: 'post',\n                contentType: 'application/json',\n                data: JSON.stringify({\n                  name: path,\n                  type: nodeToSave.type, \n                  data: nodeToSave.data\n                }),\n                success: result=>{\n                  console.log('Got result from /api/put!', result);\n                  \n                  if(skipEvent !== true){\n                    try {\n                      universe.EE.emit('nodes-modified', '');\n                    }catch(err){\n                      console.error(err);\n                    }\n                  }\n                    \n                  // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n                  let node = result;\n                  \n                  return resolve(node);\n              \n                },\n                error: errr=>{\n                  \n                  WINDOW.alert('Failed to save');\n                }\n              });\n              \n            } catch(err){\n              console.error('Failed forcePutNode', err);\n              \n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        forceNewNode(nodeToSave, opts, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            console.log('NewNode:', nodeToSave);\n                \n            // return resolve({\n            //   saveNewNode: nodeToSave\n            // });\n            \n            \n            // Make request to save Node on remote \n            try {\n              \n              // let ExternalIdentityNodes = await universe.searchMemory({\n              //   filter: {\n              //     sqlFilter: {\n              //       type: 'external_identity:0.0.1:local:8982f982j92',\n              //       data: {\n              //         commonName: 'main' // should keep using for browser development! \n              //       }\n              //     }\n              //   }\n              // });\n              // let ExternalIdentityNode = ExternalIdentityNodes[0];\n              \n              // let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n              //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n              //   data: {\n              //     action: 'send',\n              //     options: {\n              //       ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n              //       RequestNode: {\n              //         type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n              //         data: {\n              //           actions: [\n              //             {\n              //               matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n              //               dataForAction: {\n              //                 type: 'string:...',\n              //                 data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n              //               }\n              //             },\n              //             {\n              //               matchActionType: 'create_node:Qmf3892j39f8h9babb',\n              //               dataForAction: {\n              //                 type: 'create_node_data:Qmdslkfj29f0j82',\n              //                 data: {\n              //                   optionsNode: {\n              //                     type: 'options_generic:0.0.1:local:289f3j29832',\n              //                     data: opts || {}\n              //                   },\n              //                   dataNode: nodeToSave\n              //                 }\n              //               }\n              //             }\n              //           ]\n                        \n              //         }\n              //       }\n              //     }\n              //   }\n              // });\n              \n              \n              let response = await universe.$.ajax({\n                url: '/api/create',\n                method: 'post',\n                contentType: 'application/json',\n                data: JSON.stringify(nodeToSave)\n              });\n              \n              console.log('NewNode response:', response);\n              \n              // get the new node \n              let savedNode = response.data;\n              \n              if(!savedNode._id){\n                WINDOW.alert('Failed creating');\n                return false;\n              }\n              \n              \n              // console.log('Saved Node:', savedNode);\n              \n              if(skipEvent !== true){\n                try {\n                  universe.EE.emit('nodes-modified', '');\n                }catch(err){\n                  console.error(err);\n                }\n              }\n              \n              return resolve(savedNode);\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              // alert('Failed');\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            }\n            \n          })\n        }\n      \n        @autobind\n        handleKeyDown(e){\n          if(this.aceRef && this.aceRef.editor){\n            this.aceRef.editor.commands.addCommand({\n              name: 'save',\n              bindKey: {\n                win: 'Ctrl-S',\n                mac: 'Command-S'\n              },\n              exec: (env, args, request)=>{\n                // this.saveDataUpdates();\n                this.handleSaveNew();\n              }\n            });\n            \n            // overwrite Cmd-D to same as sublime \n            this.aceRef.editor.commands.addCommand({\n              name: 'selectMoreAfter2',\n              bindKey: {\n                win: 'Ctrl-D',\n                mac: 'Command-D'\n              },\n              exec: (env, args, request)=>{\n                // selectMoreAfter\n                // console.log('selectMoreAfter!');\n                this.aceRef.editor.execCommand(\"selectMoreAfter\")\n              }\n            });\n          }\n      \n        }\n        \n        @autobind\n        handleChangeMainTab(tabName){\n          \n          // using \"__ALL__\" as the \"main\" holder\n          // - otherwise assume we are editing a field \n          \n          this.setState({\n            mainTab: tabName,\n            aceHeight: 0\n          },()=>{\n            this.resizeAce();\n          })\n        }\n        \n        @autobind\n        checkForCodeUpdates(){\n          \n          // searches for updated version+ref+author \n          // - on whatever chain is specified \n          \n          return new Promise(async (resolve,reject)=>{\n            \n            console.log('Skipping checkForCodeUpdates');\n            return false;\n            \n            // let node = this.props.node;\n            let node = this.props.editStateToObj();\n          \n            console.log('checkForCodeUpdates');\n            \n            let codeTypes = [\n              'code',\n              'react_component',\n              'preparse_code',\n              'action_code'\n            ];\n            let nodeTypeName = node.type.split(':')[0];\n            if(codeTypes.indexOf(nodeTypeName) == -1){\n              console.log('Not code, not checking for code updates (should be generic \"updates\"?)');\n              return false;\n            }\n            \n            let nested = [{\n              key: 'ref',\n              value: node.data.key\n            }];\n            if(node.data.author){\n              nested.push({\n                key: 'author',\n                value: node.data.author\n              });\n            }\n            \n            if(!node.data.nodeChainNode){\n              console.log('missing chain! (no lookup)');\n              return false;\n            }\n            \n            let chainPubKey, apiAddress;\n            \n            chainPubKey = node.data.nodeChainNode.data.pubKey;\n            apiAddress = node.data.nodeChainNode.data.apiAddress;\n            \n            let chainNodes = await universe.findOnNodeChain({\n              method: 'many',\n              nested,\n              chainPubKey, \n              apiAddress\n            });\n            \n            console.log('ChainNodes:', chainNodes);\n            \n            \n            let latestNode = universe.lodash.sortBy(chainNodes,n=>{\n              return parseInt(n.version, 10)\n            });\n            if(!latestNode.length){\n              latestNode = null;\n            }\n            if(latestNode && latestNode.length){\n              latestNode = latestNode[latestNode.length - 1];\n            }\n            \n            console.log('LatestNode:', latestNode);\n            \n            this.setState({\n              chainNodes,\n              latestNode\n            })\n            \n          });\n          \n          \n        }\n        \n        @autobind\n        async handleUpdateCode(){\n          // Update code from remote \n          // - could be extended to be generic (update xyz fields for xyz type) \n          \n          try {\n              \n            // choose node to use (latest version) \n            let nodeToUse = this.state.latestNode;\n            // universe.lodash.sortBy(this.state.chainNodes,n=>{\n            //   return parseInt(n.version, 10)\n            // })\n            // if(!nodeToUse.length){\n            //   nodeToUse = null;\n            // }\n            // if(nodeToUse && nodeToUse.length){\n            //   nodeToUse = nodeToUse[nodeToUse.length - 1];\n            // }\n            \n            // console.log('Node to use:', nodeToUse);\n            \n            let data = this.props.editStateToObj().data;\n            // let data = this.props.node.data;\n            data.code = nodeToUse.data.code; //.toString();\n            data.note = nodeToUse.data.note; // ? nodeToUse.data.note.toString() : '';\n            data.internalId = nodeToUse.data.internalId;\n            data.version = nodeToUse.version.toString();// NOT .data.version! (use version on chain) \n            if(!data.author){\n              data.author = nodeToUse.author.toString(); // should be same!\n            } else {\n              console.error('Different author!');\n            }\n            \n            // create it on the server \n            let nodeToSave = {\n              _id: this.props.node._id,\n              data,\n              updatedAt: (new Date()).getTime()\n            }\n            \n            await this.makeSaveRequest(nodeToSave);\n            \n            // update whole Node \n            // - easier than updating individual parts for now\n            this.refetchNode();\n          }catch(err){\n            console.error(err);\n          }\n          \n          \n        }\n        \n        @autobind\n        renderCodeOptions(node){\n          \n          // Moved away from NodeChains for tracking code changes, for now \n          \n          // console.log('renderCodeOptions (update this with code, react_components, etc.)'); //, node);\n          \n          let codeTypes = [\n            'code',\n            'react_component',\n            'preparse_code',\n            'action_code'\n          ];\n          let nodeTypeName = node.type.split(':')[0];\n          if(codeTypes.indexOf(nodeTypeName) == -1){\n            // dont show publish\n            return '';\n          }\n          \n          let showUpdate;\n          \n          // update to latest (has a newer version on chain) (should also be able to revert) \n          // - use when no author also, but ref/key has a value \n          // - use if no version already exists \n          let latestNode = this.state.latestNode;\n          // universe.lodash.sortBy(this.state.chainNodes,n=>{\n          //   return parseInt(n.version, 10)\n          // });\n          // if(!latestNode.length){\n          //   latestNode = null;\n          // }\n          // if(latestNode && latestNode.length){\n          //   latestNode = latestNode[latestNode.length - 1];\n          // }\n          if(latestNode && latestNode.version != node.data.version){\n            showUpdate = true;\n          }\n          \n          \n          // publish (author is equal to my stored Publish PublicKey)\n          // - increment version \n          \n          // fork+publish \n          // viewAllCode: browse all nodes entered for that ref/key (TODO) \n          \n          \n          return (\n            <div className=\"control dropdown is-hoverable\">\n              <div className=\"dropdown-trigger\">\n                                        \n                <button className={\"button is-small\" + (this.state.isPublishing ? ' is-loading':'') + (showUpdate ? ' is-warning':'') + (node.data.nodeChainNode ? '':' is-danger')}>\n                  <span>\n                    Code v{node.data.version || '0'}\n                    {\n                      node.data.nodeChainNode ? '':\n                      <span className=\"\">&nbsp;No Chain</span>\n                    }\n                  </span>\n                  <span className=\"icon is-small\">\n                    <i className=\"fa fa-angle-down\"></i>\n                  </span>\n                </button>\n              </div>\n              <div className=\"dropdown-menu\">\n                <div className=\"dropdown-content\">\n                \n                  {\n                    showUpdate ? \n                      <a className=\"dropdown-item\" onClick={this.handleUpdateCode}>\n                        Update This (v{node.data.version} -&gt; v{latestNode.version})\n                      </a>\n                    :\n                      <div className=\"dropdown-item\">\n                        <i>No updates (v{node.data.version})(v{latestNode ? latestNode.version:'null'})</i>\n                      </div>\n                  }\n                  \n                  {\n                    !node.data.nodeChainNode ? '':\n                    <a className=\"dropdown-item\" onClick={this.handleExportToNodeChain}>\n                      Publish to NodeChain\n                    </a>\n                  }\n                  \n                \n                  <a className=\"dropdown-item\" onClick={this.handleChangeNodeChainData}>\n                    Change NodeChain\n                  </a>\n                  \n                </div>\n              </div>\n            </div>\n                  \n          )\n                        \n                        \n        }\n        \n        @autobind\n        updateRemoteIdentity(){\n          return new Promise(async (resolve, reject) => {\n            \n            // make request to update remote identity \n            // - TODO: dont keep here \n              \n            let username = WINDOW.prompt('Username (case-sensitive):','');\n            if(!username){\n              return false;\n            }\n      \n            username = username.trim();\n  \n            this.setState({\n              registeringUsername: true\n            })\n            \n            // Make request to save Node on remote \n            try {\n              \n              // let ExternalIdentityNodes = await universe.searchMemory({\n              //   filter: {\n              //     sqlFilter: {\n              //       type: 'external_identity:0.0.1:local:8982f982j92',\n              //       data: {\n              //         commonName: 'main'\n              //       }\n              //     }\n              //   }\n              // });\n              // let ExternalIdentityNode = ExternalIdentityNodes[0];\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                          {\n                            matchActionType: 'register_identity:0.0.1:local:209fj2sdf23fbb',\n                            dataForAction: {\n                              type: 'string:0.0.1:local:0923jf',\n                              data: username\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('register_identity response:', response);\n              \n              this.setState({\n                registeringUsername: false\n              })\n              \n              let registerResult = response.data.actionResponses[1].data.registeredExternal.data;\n              if(!registerResult){\n                throw \"Failed, result not a boolean true\";\n              }\n                \n              universe.StellarSdk.Network.useTestNetwork();\n              let stellarServer = new universe.StellarSdk.Server('https://horizon-testnet.stellar.org');\n              let pkTargetSeed = universe.crypto.createHash('sha256').update(username).digest();\n              var pairTarget = universe.StellarSdk.Keypair.fromRawEd25519Seed(pkTargetSeed);\n              \n              WINDOW.prompt(`Registered remote Second on chain using username: ${username}\nAccount (publicKey): ${pairTarget.publicKey()}`, pairTarget.publicKey());\n\n              // cant WINDOW.open for some reason \n              let launchUrl = `https://horizon-testnet.stellar.org/accounts/${pairTarget.publicKey()}`;\n              console.log('Launch in new window', launchUrl);\n              // WINDOW.open(launchUrl,'_blank');\n              \n              return resolve({\n                type: 'node:...',\n                data: response.data.actionResponses[1]\n              });\n              \n            } catch(err){\n              console.error('Failed register_identity', err);\n              \n              WINDOW.alert('Failed');\n              \n                \n              this.setState({\n                registeringUsername: false\n              })\n              \n              return reject();\n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        checkIdentity(){\n          return new Promise(async(resolve,reject)=>{\n              \n            // lookup a username (if it exists) \n            // - get the IPFS hash for the user too (and parse the Identity) \n              \n            let username = WINDOW.prompt('Username (case-sensitive):','');\n            if(!username){\n              return false;\n            }\n      \n            username = username.trim();\n            \n            let subname = ''; // empty is for root \n            let usernameSplit = username.split('@');\n            if(usernameSplit.length > 1){\n              subname = usernameSplit[0];\n              username = usernameSplit[1];\n            }\n            \n            console.log('Checking Identity');\n            \n            universe.StellarSdk.Network.useTestNetwork();\n            let stellarServer = new universe.StellarSdk.Server('https://horizon-testnet.stellar.org');\n            \n            console.log('stellarServer', stellarServer);\n            \n            let pkTargetSeed = universe.crypto.createHash('sha256').update(username).digest(); //returns a buffer\n            console.log('pkTargetSeed', pkTargetSeed);\n            \n            var pairTarget = universe.StellarSdk.Keypair.fromRawEd25519Seed(pkTargetSeed);\n            \n            console.log('pairTarget', pairTarget);\n            \n            let targetAccount;\n            try {\n              targetAccount = await stellarServer.loadAccount(pairTarget.publicKey())\n              console.log('targetAccount:', targetAccount);\n            }catch(err){\n              // console.error('Failed getting targetAccount', err);\n              // this.setState({\n              //   findingHash: false,\n              //   errors: ['Unable to load Identity/Username']\n              // });\n              WINDOW.alert('Unable to load account for username');\n              return false;\n            }\n            \n                  \n            // get the current value of the Second ipfshash \n            let secondHash = await targetAccount.data({key: subname + '|second'})\n            .then(function(dataValue) {\n              let decoded = atob(dataValue.value);\n              return decoded;\n            })\n            .catch(function (err) {\n              return null;\n            })\n      \n            console.log('secondHash:', secondHash);\n            let cont = WINDOW.prompt(`\nAccountId: ${pairTarget.publicKey()}\nIdentity IPFS Hash: ${secondHash}\n\nLoad ipfshash?\n            `,'y');\n            if(cont != 'y' || !secondHash || !secondHash.length){\n              return false\n            }\n            \n            this.loadHashData(secondHash);\n            \n          })\n        }\n        \n        @autobind\n        async loadHashData(hash){\n            \n          // this.setState({\n          //   fetchingIpfs: true,\n          //   ipfsData: null\n          // });\n          // let hash = this.state.hash;\n          \n          console.log('Fetching ipfs hash:', hash);\n          \n          try {\n            let data = await universe.ipfs.files.cat(hash);\n            \n            data = JSON.stringify(JSON.parse(data),null,2);\n            \n            console.log('ipfs Data:', data);\n            \n            WINDOW.alert(`${data}`);\n            \n            \n          } catch(err){\n            WINDOW.alert('Failed fetching ipfs Hash');\n          }\n          \n          \n        }\n        \n        render(){\n          \n          // add \"fields\" to mainTab for the selected Node \n          // - also should show \"unused\" fields from schema? \n          \n          // let node = this.props.node;\n          let node = this.props.editStateToObj();\n      \n          let { value, parentValue } = this.props.editState.fields.data; // value is always a String!!!! (might not be Parseable tho!) \n    \n          let mainTabs = [\n            ['__ALL__','All']\n          ]\n      \n          let dataBeforeParse = value;\n          let isValidJSON = true;\n          let parsedData;\n          try {\n            parsedData = JSON.parse(dataBeforeParse);\n          }catch(err){\n            isValidJSON = false;\n          }\n      \n      \n          // validates?\n          let data = value;\n          let isValidDataForSchema = false;\n          let schemaValidationErrors = '';\n      \n      \n          if(this.state.schema){\n      \n            if(this.state.schema.type == 'object'){\n      \n              if(typeof data == 'string'){\n                try {\n                  data = JSON.parse(data);\n                }catch(err){\n                  // return false;\n                  data = null;\n                }\n              } else {\n                // leave as-is (assume String/Number) \n              }\n      \n            } else {\n              // use raw value\n              // data = dataBeforeParse;\n            }\n      \n            try {\n              let validate = universe.jsSchema.fromJSON(this.state.schema);\n              let validates = validate(data);\n              // console.log('validates:', validates);\n              if(validates){ \n                isValidDataForSchema = true;\n              } else {\n                schemaValidationErrors = validate.errors(data);\n              }\n              // console.log('schemaValidationErrors',schemaValidationErrors);\n            }catch(err){\n              console.error('jsSchema err:', err);\n            }\n            \n            // tabs\n            if(this.state.schema.type == 'object'\n              && isValidJSON){\n              try {\n                let objTabs = Object.keys(parsedData).map(d=>{return [d,d]});\n                mainTabs = mainTabs.concat(objTabs);\n              }catch(err){\n                \n              }\n            }\n            \n          }\n          \n          let outputVal;\n          if(this.state.mainTab != '__ALL__'){\n            // this.props.editState.fields.data.value ? this.props.editState.fields.data.value.code:''\n            try {\n              // console.log('dATAVAL',this.props.editState.fields.data.value);\n              value = JSON.parse(this.props.editState.fields.data.value)[this.state.mainTab];\n            }catch(err){\n              console.error('failed parsing value for field.', err);\n            }\n          }\n          \n          let showEditor = true,\n            showJSONRepresentation = false;\n          if(universe.lodash.isString(value)){\n            // default, expecting an editable string \n          } else {\n            showEditor = false;\n            showJSONRepresentation = true;\n          }\n          \n          // get path to node (by name) \n          let nodePaths = [];\n          function addParent(node){\n            nodePaths.push(node.name);\n            if(node.parent){\n              addParent(node.parent);\n            }\n          }\n          addParent(node);\n          \n          nodePaths = nodePaths.reverse();\n          \n          return (\n            <div className=\"fill-height-or-more\">\n              <div style={{flex:'0 1 auto'}}>\n                <div style={{padding: '4px'}}>\n                  <div className=\"level-NOTANYMORE\">\n                    <div className=\"level-right-NOTANYMORE is-pulled-right\">\n                      <div className=\"level-item-NOTANYMORE\">\n                        <div className=\"field is-grouped\">\n                        \n                          \n                          <div className=\"control dropdown is-right is-hoverable\">\n                            <div className=\"dropdown-trigger\">\n                                                      \n                              <button className={\"button is-small\"}>\n                                <span>More</span>\n                                <span className=\"icon is-small\">\n                                  <i className=\"fa fa-angle-down\"></i>\n                                </span>\n                              </button>\n                            </div>\n                            <div className=\"dropdown-menu\">\n                              <div className=\"dropdown-content\">\n                              \n                                <a className=\"dropdown-item\" onClick={this.checkIdentity}>\n                                  Check Identity\n                                </a>\n                                \n                                <a className=\"dropdown-item\" onClick={this.updateRemoteIdentity}>\n                                  Register Identity\n                                </a>\n                                \n                              </div>\n                            </div>\n                          </div>\n                          \n                          <div className=\"control dropdown is-right is-hoverable\">\n                            <div className=\"dropdown-trigger\">\n                                                      \n                              <button className={\"button is-small is-danger\"}>\n                                <span>Delete</span>\n                                <span className=\"icon is-small\">\n                                  <i className=\"fa fa-angle-down\"></i>\n                                </span>\n                              </button>\n                            </div>\n                            <div className=\"dropdown-menu\">\n                              <div className=\"dropdown-content\">\n                              \n                                <a className=\"dropdown-item is-danger\" onClick={this.handleDelete}>\n                                  This Node\n                                </a>\n                                \n                                {\n                                  !(node.nodes && node.nodes.length) ? '':\n                                  <a className=\"dropdown-item is-danger\" onClick={this.handleDeleteChildren}>\n                                    Child Nodes\n                                  </a>\n                                }\n                                \n                              </div>\n                            </div>\n                          </div>\n                        </div>\n                        \n                      </div>\n                    </div>\n                    <div className=\"level-left-NOTANYMORE\">\n                      <div className=\"level-item-NOTANYMORE\">\n                        <h3 className=\"title is-5\">\n                          {\n                            node.name\n                          }\n                        </h3>\n                        <h3 className=\"subtitle is-6\">\n                          {node.type}\n                        </h3>\n                      </div>\n                    </div>\n                  </div>\n                </div>\n              </div>\n              <div style={{flex:'0 1 auto'}}>\n                <div style={{padding: '4px'}}>\n                  <div className=\"level\">\n                    <div className=\"level-left\">\n                      <div className=\"level-item\">\n                        <div className=\"field is-grouped\">\n                          <p className=\"control\">\n                            <a className=\"button is-small\" onClick={this.handleMove}>\n                              Move\n                            </a>\n                          </p>\n                          <p className=\"control\">\n                            <a className=\"button is-small\" onClick={this.handleDuplicate}>\n                              Duplicate\n                            </a>\n                          </p>\n                          <p className=\"control\">\n                            <a className=\"button is-small\" onClick={this.handleUpdateType}>\n                              Type\n                            </a>\n                          </p>\n                          <p className=\"control\">\n                            <a className=\"button is-small\" onClick={this.handleUpdateParent}>\n                              Parent\n                            </a>\n                          </p>\n                          \n                          <div className=\"control dropdown is-hoverable\">\n                            <div className=\"dropdown-trigger\">\n                                                      \n                              <button className={\"button is-small\" + (this.state.addingChild ? ' is-loading':'')}>\n                                <span>Add Child</span>\n                                <span className=\"icon is-small\">\n                                  <i className=\"fa fa-angle-down\"></i>\n                                </span>\n                              </button>\n                            </div>\n                            <div className=\"dropdown-menu\">\n                              <div className=\"dropdown-content\">\n                              \n                                <a className=\"dropdown-item\" onClick={this.handleAddChild}>\n                                  Blank\n                                </a>\n                                \n                                <a className=\"dropdown-item\" onClick={e=>this.setState({pastable: !this.state.pastable})}>\n                                  Paste JSON\n                                </a>\n                                \n                                <a className=\"dropdown-item\" onClick={this.handleImportZip}>\n                                  Import Bundle (from GitHub)\n                                </a>\n                                \n                              </div>\n                            </div>\n                          </div>\n                          \n                          <div className=\"control dropdown is-hoverable\">\n                            <div className=\"dropdown-trigger\">\n                                                      \n                              <button className={\"button is-small\" + (this.state.fetchingParents ? ' is-loading':'')}>\n                                <span>Export</span>\n                                <span className=\"icon is-small\">\n                                  <i className=\"fa fa-angle-down\"></i>\n                                </span>\n                              </button>\n                            </div>\n                            <div className=\"dropdown-menu\">\n                              <div className=\"dropdown-content\">\n                              \n                                <a className=\"dropdown-item\" onClick={this.handleExportNode}>\n                                  Node to Clipboard\n                                </a>\n                                \n                                <a className=\"dropdown-item\" onClick={this.handleExportChildren}>\n                                  Children to ClipBoard\n                                </a>\n                                \n                                {\n                                  (!node.type || node.type.split(':')[0] != 'node_repo_on_github') ? '':\n                                  <div>\n                                    <div className=\"dropdown-divider\"></div>\n                                    <a className=\"dropdown-item\" onClick={this.handleExportChildrenToLocalStorage}>\n                                      Export App to LocalStorage\n                                    </a>\n                                    <a className=\"dropdown-item\" onClick={this.handleExportChildrenToGitHub}>\n                                      Export App to GitHub\n                                    </a>\n                                    <a className=\"dropdown-item\" onClick={this.handleClearGitHubCredentials}>\n                                      Clear GitHub Credentials\n                                    </a>\n                                  </div>\n                                }\n                                \n                                {\n                                  (!node.type || node.type.split(':')[0] != 'platform_nodes') ? '':\n                                  <div>\n                                    <div className=\"dropdown-divider\"></div>\n                                    <a className=\"dropdown-item\" onClick={this.handleExportChildrenToLocalStorage}>\n                                      Export App to LocalStorage\n                                    </a>\n                                    <a className=\"dropdown-item\" onClick={this.handleExportChildrenToGitHub}>\n                                      Export App to GitHub\n                                    </a>\n                                    <a className=\"dropdown-item\" onClick={this.handleClearGitHubCredentials}>\n                                      Clear GitHub Credentials\n                                    </a>\n                                  </div>\n                                }\n                                \n                                {\n                                  (node.type && (node.type.split(':')[0] == 'app_base') ) ? \n                                  <div>\n                                    <div className=\"dropdown-divider\"></div>\n                                    {\n                                      (node.data && node.data.sharedNodeId) ?\n                                        <a className=\"dropdown-item\" onClick={e=>this.handleExportChildrenToSharedNode(true)}>\n                                          Export App to SharedNode\n                                        </a>\n                                      :\n                                        <a className=\"dropdown-item\" onClick={e=>this.handleExportChildrenToSharedNode(true)}>\n                                          Create SharedNode\n                                        </a>\n                                    }\n                                    <a className=\"dropdown-item\" onClick={e=>this.handleExportChildrenToLocalStorage(true)}>\n                                      Export App to LocalStorage\n                                    </a>\n                                    {\n                                      (node.data && node.data.repo) ?\n                                        <a className=\"dropdown-item\" onClick={e=>this.handleExportChildrenToGitHub(true)}>\n                                          Export App to GitHub\n                                        </a>\n                                      :\n                                        <a className=\"dropdown-item\" onClick={e=>this.handleCreateGitHubRepoForApp(true)}>\n                                          Create GitHub Repo\n                                        </a>\n                                    }\n                                    <a className=\"dropdown-item\" onClick={this.handleClearGitHubCredentials}>\n                                      Clear GitHub Credentials\n                                    </a>\n                                  </div>\n                                  :''\n                                }\n                                \n                                {\n                                  (node.type && (node.type.split(':')[0] == 'app_parts') ) ? \n                                  <div>\n                                    <div className=\"dropdown-divider\"></div>\n                                    <a className=\"dropdown-item\" onClick={e=>this.handleExportChildrenToLocalStorage(true)}>\n                                      Export AppParts to LocalStorage\n                                    </a>\n                                    {\n                                      (node.data && node.data.repo) ?\n                                        <a className=\"dropdown-item\" onClick={e=>this.handleExportChildrenToGitHub(true)}>\n                                          Export AppParts to GitHub\n                                        </a>\n                                      :\n                                        <a className=\"dropdown-item\" onClick={e=>this.handleCreateGitHubRepoForApp(true)}>\n                                          Create GitHub Repo\n                                        </a>\n                                    }\n                                    <a className=\"dropdown-item\" onClick={this.handleClearGitHubCredentials}>\n                                      Clear GitHub Credentials\n                                    </a>\n                                  </div>\n                                  :''\n                                }\n                                \n                                {/*\n                                  (this.state.parentNodes || []).map(parentNode=>{\n                                    return (\n                                      <a key={parentNode._id} className=\"dropdown-item\" onClick={e=>this.handleExportChildrenToLocalStorage(parentNode.data.learn)}>\n                                        To LocalStorage: <strong>{parentNode.data ? parentNode.data.learn:'missing'}</strong>\n                                      </a>\n                                    )\n                                  })\n                                */}\n                                \n                                \n                              </div>\n                            </div>\n                          </div>\n                          \n                          {/*\n                            this.renderCodeOptions(node)\n                          */}\n                          \n                          {/*\n                          <p className=\"control\">\n                            <a className=\"button is-default is-small\" onClick={this.saveDataUpdates}>\n                              Save (old)\n                            </a>\n                          </p>\n                          */}\n                          \n                          <p className=\"control\">\n                            <a className=\"button is-success is-small\" onClick={this.handleSaveNew}>\n                              Save (New)\n                            </a>\n                          </p>\n                          \n                          \n                          {\n                            !this.state.fetchingRemote ? '':\n                            <p className=\"control\">\n                              <a className={\"button is-small is-white is-loading\"}>\n                                &nbsp;\n                              </a>\n                              <a className={\"button is-small is-white\"}>\n                                Fetching remote...\n                              </a>\n                            </p>\n                          }\n                          \n                          {\n                            !this.state.isPublishing ? '':\n                            <p className=\"control\">\n                              <a className={\"button is-small is-white is-loading\"}>\n                                &nbsp;\n                              </a>\n                              <a className={\"button is-small is-white\"}>\n                                Publishing...\n                              </a>\n                            </p>\n                          }\n                          \n                          {\n                            !this.state.saving ? '':\n                            <p className=\"control\">\n                              <a className={\"button is-small is-white is-loading\"}>\n                                &nbsp;\n                              </a>\n                              <a className={\"button is-small is-white\"}>\n                                Saving...\n                              </a>\n                            </p>\n                          }\n                          \n                          {\n                            !this.state.registeringUsername ? '':\n                            <p className=\"control\">\n                              <a className={\"button is-small is-white is-loading\"}>\n                                &nbsp;\n                              </a>\n                              <a className={\"button is-small is-white\"}>\n                                Registering Username...\n                              </a>\n                            </p>\n                          }\n                          \n                          {\n                            !this.state.updatingGit ? '':\n                            <p className=\"control\">\n                              <a className={\"button is-small is-white is-loading\"}>\n                                &nbsp;\n                              </a>\n                              <a className={\"button is-small is-white\"}>\n                                Updating GitHub...({this.state.updatingGit})\n                              </a>\n                            </p>\n                          }\n                        </div>\n                      </div>\n                    </div>\n                  </div>\n                </div>\n              </div>\n              \n              {\n                !this.state.pastable ? '':\n                <div>\n                  <textarea className=\"textarea\" value={this.state.pasteText} onChange={e=>this.setState({pasteText:e.target.value})} />\n                  <button className=\"button\" onClick={this.handleAddChildPaste}>Save</button>\n                </div>\n              }\n              \n              <div style={{flex:'0 1 auto'}}>\n                <div className=\"tabs\">\n                  <ul>\n                    {\n                      mainTabs.map(tab=>(\n                        <li \n                          key={tab[0]}\n                          className={this.state.mainTab == tab[0] ? \"is-active\":''}\n                          onClick={e=>this.handleChangeMainTab(tab[0])}\n                        ><a>{tab[1]}</a></li>\n                      ))\n                    }\n                  </ul>\n                </div>\n              </div>\n              \n              <div \n                className=\"\" \n                style={{flex:'1 1 auto'}}\n                ref={r=>this.parentRef=r}\n                >\n                <div \n                  style={{height: this.state.aceHeight+'px', position: 'relative'}} \n                  >\n                  \n                  {\n                    !showEditor ? '':\n                    <AceEditor\n                      ref={r=>this.aceRef=r}\n                      mode=\"jsx\"\n                      theme=\"monokai\"\n                      value={value}\n                      onChange={v=>{\n                        if(this.state.mainTab == '__ALL__'){\n                          // if(this.state.schema.type == 'object'){\n                          //   this.props.setEditState('data', v)\n                          // } else {\n                          //   // raw\n                            this.props.setEditState('data', v)\n                          // }\n                        } else {\n                          let newObj = {};\n                          newObj[this.state.mainTab] = v;\n                          // console.log('onchangedata:', data, this.props.editState.fields.data);\n                          let newData = Object.assign({},data,newObj)\n                          this.props.setEditState('data', JSON.stringify(newData));\n                        }\n                      }}\n                      name=\"UNIQUE_ID_OF_DIV2\"\n                      editorProps={{$blockScrolling: true}}\n                      width=\"100%\"\n                      height=\"100%\"\n                      onLoad={editor=>{\n                        editor.getSession().setUseWrapMode(true);\n                      }}\n                      setOptions={{\n                        enableBasicAutocompletion: true,\n                        enableLiveAutocompletion: true,\n                        showPrintMargin: false,\n                        enableSnippets: true,\n                        behavioursEnabled: false,\n                        showLineNumbers: true,\n                        tabSize: 2\n                      }}\n                    />\n                  }\n                  \n                  {\n                    !showJSONRepresentation ? '':\n                    <pre><code>{JSON.stringify(value,null,2)}</code></pre>\n                  }\n                  \n                </div>\n              </div>\n            </div>\n          )\n        }\n      }\n      \n      mycomponent = universe.ReactGlobalState(mycomponent);\n      \n      mycomponent = universe.withEditManager(mycomponent,{\n        editProp: 'node',\n        fields: ['type','data'],\n        fieldConvertServerOnceFunc: {\n          data: v=>{\n            return JSON.stringify(v,null,2)\n          }\n        },\n        fieldOutputFunc: {\n          data: v=>{\n            return JSON.parse(v)\n          }\n        },\n        fieldConvertServerFunc: {\n          // tmpData: v=>{\n          //   if(v){\n      \n          //   }\n          //   return v;\n          // }\n          // data: v=>{\n          //   // jsSchema\n          //   // console.log('NewServerData:', v);\n          //   if(v instanceof String){\n          //     return v;\n          //   }\n          //   return JSON.stringify(v);\n          //   // return JSON.stringify({\n          //   //   data: v // necessary to do this to retain correct types? \n          //   // },null,2)\n          // }\n        },\n        fieldCompareFunc: {\n          // uri: (prev, next)=>{\n          //   console.log('URI compare!:', prev, next);\n          //   return prev === next;\n          // }\n        }\n      });\n\n      resolve({\n        type: 'types.second.default.react_component',\n        data: mycomponent\n      });\n      \n    }catch(err){\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n  \n})()"
  // // }
  // //   }) 
  // //   await App.secondAI.MySecond.putNodeAtPath('app.second.deveditor.frontend.data.react_components.main.developer_window.left_browser',{
  // //     type: 'types.second.default.react_component.js',
  // //     data: { "code": "(()=>{\n  \n  let __parsedFiles = {};\n  function jsonParse(key, contents){\n    if(__parsedFiles[key]){\n      return __parsedFiles[key]\n    }\n  \n    __parsedFiles[key] = JSON.parse(contents);\n    return __parsedFiles[key];\n  \n  }\n    \n  function matchRuleShort(str, rule) {\n    return new RegExp(\"^\" + rule.split(\"*\").join(\".*\") + \"$\").test(str);\n  }\n  \n  function pathMatch(path, pattern){\n    // pattern: xyz.%.%.* something \n    \n    let pathSplit = path.split('.');\n    let patternSplit = pattern.split('.');\n  \n    let doesMatch = false;\n    let stopCheckingPathCuzFailed;\n    pathSplit.forEach((name,idx)=>{\n      if(stopCheckingPathCuzFailed){\n        return;\n      }\n  \n      let isLastName = (idx == (pathSplit.length - 1)) ? true:false;\n      let isLastPattern = (idx == (patternSplit.length - 1)) ? true:false;\n  \n      let patternForSegment = patternSplit[idx];\n  \n      // console.log('name', name);\n      // console.log('pattern', pattern);\n      // console.log('isLast', isLast);\n  \n      if(patternForSegment == '**'){\n        // console.log('Match **');\n        stopCheckingPathCuzFailed = true;\n        doesMatch = true;\n        return;\n      }\n      \n      if(patternForSegment == '' && isLastName && isLastPattern){\n        // same as \".*\"\n        doesMatch = true;\n        return;\n      }\n      \n      if(typeof patternForSegment != 'string'){\n        // failed\n        stopCheckingPathCuzFailed = true;\n        return;\n      }\n  \n      if(matchRuleShort(name, patternForSegment)){\n        if(isLastName){\n          if(isLastPattern){\n            doesMatch = true;\n          } else {\n            // not a match \n            stopCheckingPathCuzFailed = true;\n          }\n        } else {\n          // just continue to checking the next part of this path! \n          // console.log('continue checking');\n        }\n      } else {\n        stopCheckingPathCuzFailed = true;\n      }\n  \n    })\n  \n    return doesMatch;\n    \n  }\n  \n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      class ErrorComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              [ErrorRenderer]\n            </div>\n          )\n        }\n      }\n      \n      class ListComponent extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {\n            nodes: [],\n            text: '',\n            pastable: false,\n            pasteText: '',\n            showChildren: true\n          }\n        }\n        \n        componentDidMount(){\n          this.fetchRemoteNodes();\n          \n          \n          universe.EE.on('nodes-modified', this.fetchRemoteNodes);\n        \n        }\n        componentWillUnmount(){\n          universe.EE.removeListener('nodes-modified', this.fetchRemoteNodes);\n        }\n        \n        @autobind\n        fetchRemoteNodes_OLD(){\n          \n          // \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n              \n              this.setState({\n                fetchingRemote: true\n              })\n              \n              // let ExternalIdentityNodes = await universe.searchMemory({\n              //   filter: {\n              //     sqlFilter: {\n              //       type: 'external_identity:0.0.1:local:8982f982j92',\n              //       data: {\n              //         commonName: 'main'\n              //       }\n              //     }\n              //   }\n              // });\n              // let ExternalIdentityNode = ExternalIdentityNodes[0];\n              \n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                          {\n                            matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                            dataForAction: {\n                              type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              data: {\n                                responseType: 'cjson',\n                                dataFilter: {\n                                  nodeId: null\n                                },\n                                matchFunctionNode: {\n                                  // query here!\n                                  // action_pointer:0.0.1:local:238972ncr\n                                  type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                  data: {\n                                    code: `(()=>{\n                                      // Action \n                                      // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                      \n                                      let inputNode = INPUT.data.inputNode;\n                                      \n                                      if(inputNode.nodeId){\n                                        return false;\n                                      }\n                                      \n                                      // let childNodes = INPUT.data.inputNode.nodes;\n                                      \n                                      // let returnNode = miniverse.lodash.omit(,['data']);\n                                      \n                                      // rebuild children w/o data \n                                      function noData(node){\n                                                                            \n                                        // active: true\n                                        // createdAt: 1524632541511\n                                        // name: \"platform_nodes\"\n                                        // nodeId: \"5ae00bdd6b2f710021b72238\"\n                                        // nodes: (86)\n                                        // parent: Node,\n                                        // placeholder: false\n                                        // type: \"platform_nodes:Qmtlksjflsdjfljf\"\n                                        // updatedAt: null\n                                        // _id: \"5ae00bdd6b2f710021b72239\"\n                                        // _path: \"app_store_cloud.platform_nodes\"\n                                        // _root: Node,\n                                        // _rootChain: (2) []\n                                        \n                                        let newNode = miniverse.lodash.pick(node, [\n                                          '_id',\n                                          'nodeId',\n                                          'type',\n                                          'name',\n                                          '_path',\n                                          'placeholder',\n                                          'createdAt',\n                                          'updatedAt'\n                                        ])\n                                        newNode.data = undefined;\n                                        newNode.nodes = [];\n                                        if(node.nodes){\n                                          node.nodes.forEach(tmpNode2=>{\n                                            newNode.nodes.push(noData(tmpNode2));\n                                          })\n                                        }\n                                        return newNode;\n                                      }\n                                      \n                                      // if(inputNode.type != 'learning_pointer:0.0.1:local:3289h3238h92'){\n                                      //   return null;\n                                      // }\n                                      \n                                      // if(inputNode.data.learn != 'browser_developer'){\n                                      //   return null;\n                                      // }\n                                      \n                                      // // strip childnodes\n                                      // // delete inputNode.nodes; \n                                      // // delete inputNode.parent;\n                                      // delete inputNode.data; // deletes in memory?\n                                      // inputNode.data2 = 'testing2';\n              \n                                      return noData(inputNode);\n                                      \n                                    })()`\n                                  }\n                                },\n                                // expected/allowed schemas for return \n                                // outputSchemas: [\n                                //   'query_result:0.0.1:local:32490usfj23o23f',\n                                //   'internal_error_output:0.0.1:local:32948x2u3cno2c'\n                                // ]\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              let nodes = response.data.actionResponses[1].data;\n              \n              if(typeof nodes == 'string'){\n                console.log('cjson returned for nodes');\n                nodes = universe.cJSON.parse(nodes);\n              } else {\n                console.log('NOT CJSON!');\n              }\n              \n              console.log('Nodes:', nodes);\n              \n              // let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                nodes: nodes,\n                fetchingRemote: false,\n                selectedNodes: []\n              })\n              \n              // // Update the \"editingNode\" too \n              // // - ideally wouldn't reload the window, but oh well? \n              // let editingNode = this.props.state.editingNode;\n              // if(editingNode){\n                \n              //   function checkChildren(nodes){\n              //     for(let node of nodes){\n              //       if(node._id == editingNode._id){\n              //         editingNode = node;\n              //       }\n              //       if(node.nodes){\n              //         checkChildren(node.nodes);\n              //       }\n              //     }\n              //   }\n              //   checkChildren(nodes);\n              // }\n              \n              // console.log('EditingNode to update:', editingNode);\n              // // this.props.setState({\n              // //   editingNode\n              // // });\n              \n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              this.setState({\n                fetchingRemote: false\n              })\n              \n            }\n            \n          });\n          \n          \n          // this.setState({\n          //   value: 5\n          // });\n          \n          // WINDOW.alert(10);\n          // let x = WINDOW.prompt('what','');\n          // this.setState({\n          //   value: parseInt(x,10)\n          // })\n          \n          \n          // let IdentityNode = null;\n          // let identities = await universe.searchMemory({\n          //   filter: {\n          //     sqlFilter: {\n          //       type: 'remote_datasource:0.0.1:local:298f3h92hf9s8dhf23f'\n          //     },\n          //     // function for returning data from the Node, after filtering a bit \n          //     // - includes both the Node, and Nodes with nodeId (pointers) \n          //     filterNodes: tmpNodes=>{\n          //       // this runs isolated, outside of the above context? (not sure) \n          //       return new Promise((resolve, reject)=>{\n          //         resolve(tmpNodes);\n          //       });\n          //     },\n          //   }\n          // });\n        }\n        \n        @autobind\n        fetchRemoteNodes(){\n        // fetchRemoteNodesByPath(){\n          \n          // \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n              \n              this.setState({\n                fetchingRemote: true\n              })\n              \n              \n              \n              universe.$.ajax({\n                url: '/api/get_for_pattern',\n                method: 'post',\n                contentType: 'application/json',\n                data: JSON.stringify({\n                  paths: ['*'],\n                  excludeData: true\n                }),\n                success: result=>{\n                  console.log('Got result from /get!'); //, result);\n                  \n                  let nodes = result; // TODO: result.data.nodes when type is setup \n                  \n                  if(typeof nodes == 'string'){\n                    console.log('cjson returned for nodes');\n                    nodes = universe.cJSON.parse(nodes);\n                  } else {\n                    console.log('NOT CJSON!');\n                  }\n                  \n                  console.log('Nodes:', nodes);\n                  \n                  // let componentNode = await universe.runInVM(result[0],{});\n                  this.setState({\n                    nodes: nodes,\n                    fetchingRemote: false,\n                    selectedNodes: []\n                  })\n                  \n                  // // Update the \"editingNode\" too \n                  // // - ideally wouldn't reload the window, but oh well? \n                  // let editingNode = this.props.state.editingNode;\n                  // if(editingNode){\n                    \n                  //   function checkChildren(nodes){\n                  //     for(let node of nodes){\n                  //       if(node._id == editingNode._id){\n                  //         editingNode = node;\n                  //       }\n                  //       if(node.nodes){\n                  //         checkChildren(node.nodes);\n                  //       }\n                  //     }\n                  //   }\n                  //   checkChildren(nodes);\n                  // }\n                  \n                  // console.log('EditingNode to update:', editingNode);\n                  // // this.props.setState({\n                  // //   editingNode\n                  // // });\n                  \n                  \n                },\n                error: errr=>{\n                  \n                  console.error('Failed to /get');\n                    \n                  this.setState({\n                    fetchingRemote: false\n                  })\n                  \n                  // WINDOW.alert('Failed to /get');\n                }\n              });\n              \n              \n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              this.setState({\n                fetchingRemote: false\n              })\n              \n            }\n            \n          });\n        }\n        \n        @autobind\n        fetchRemoteSingleNodeNew(nodePath){\n          \n          // \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n              \n              this.setState({\n                fetchingRemote: true\n              })\n              \n              \n              universe.$.ajax({\n                url: '/api/get',\n                method: 'post',\n                contentType: 'application/json',\n                data: JSON.stringify({name: nodePath}),\n                success: result=>{\n                  console.log('Got result from /get!', result);\n                    \n                  // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n                  let node = universe.cJSON.parse(result);\n                  \n                  console.log('Node Got:', node);\n                  \n                  this.setState({\n                    fetchingRemote: false\n                  })\n                  \n                  return resolve(node);\n              \n                },\n                error: err=>{\n                    \n                  this.setState({\n                    fetchingRemote: false\n                  })\n                  \n                  WINDOW.alert('Failed to save');\n                }\n              });\n              \n              \n            } catch(err){\n              console.error('Failed getting local single node');\n              \n              this.setState({\n                fetchingRemote: false\n              })\n              \n            }\n            \n          });\n        }\n        \n        @autobind\n        fetchRemoteSingleNode(nodeId){\n          \n          // \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n              \n              this.setState({\n                fetchingRemote: true\n              })\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                          {\n                            matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                            dataForAction: {\n                              type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              data: {\n                                responseType: 'cjson',\n                                dataFilter: {\n                                  _id: nodeId\n                                },\n                                matchFunctionNode: {\n                                  // query here!\n                                  // action_pointer:0.0.1:local:238972ncr\n                                  type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                  data: {\n                                    code: `(()=>{\n                                      // Action \n                                      // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                      \n                                      let inputNode = INPUT.data.inputNode;\n                                      \n                                      // rebuild children w/o data \n                                      function cleanNode(node){\n                                        \n                                        // data included, NO PARENT/ROOT \n                                        \n                                        let newNode = miniverse.lodash.pick(node, [\n                                          '_id',\n                                          'nodeId',\n                                          'type',\n                                          'name',\n                                          '_path',\n                                          'data',\n                                          'placeholder',\n                                          'createdAt',\n                                          'updatedAt'\n                                        ])\n                                        newNode.nodes = [];\n                                        if(node.nodes){\n                                          node.nodes.forEach(tmpNode2=>{\n                                            newNode.nodes.push(cleanNode(tmpNode2));\n                                          })\n                                        }\n                                        return newNode;\n                                      }\n                                      \n                                      return cleanNode(inputNode);\n                                      \n                                    })()`\n                                  }\n                                },\n                                // expected/allowed schemas for return \n                                // outputSchemas: [\n                                //   'query_result:0.0.1:local:32490usfj23o23f',\n                                //   'internal_error_output:0.0.1:local:32948x2u3cno2c'\n                                // ]\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              let nodes = response.data.actionResponses[1].data;\n              \n              if(typeof nodes == 'string'){\n                console.log('cjson returned for nodes');\n                nodes = universe.cJSON.parse(nodes);\n              } else {\n                console.log('NOT CJSON!');\n              }\n              \n              console.log('Nodes:', nodes);\n              \n              // let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                fetchingRemote: false,\n              })\n              \n              return resolve(nodes[0]);\n              \n            } catch(err){\n              console.error('Failed getting local single node');\n              \n              this.setState({\n                fetchingRemote: false\n              })\n              \n            }\n            \n          });\n        }\n      \n        @autobind\n        handleNewNode(){\n      \n          return new Promise(async (resolve,reject)=>{\n        \n            let name = WINDOW.prompt('Name (blank for random, replace % with UUID)','');\n            if(typeof name != 'string'){\n              console.log('canceled');\n              return false;\n            }\n            \n            name = name.trim();\n            \n            if(name == ''){\n              name = universe.uuidv4();\n            }\n            \n            name = name.replace(/\\%/g,()=>{\n              return universe.uuidv4();\n            });\n            \n            console.log('name:', name);\n            \n            \n            let type;\n            type = WINDOW.prompt('Type (types.second.default.code)','types.second.default.x');\n            if(!type){\n              return false;\n            }\n            \n            type = type.trim();\n            \n            // todo: get and validate the type's schema. use schema for default data\n            \n            let newNode = {\n              // nodeId: node._id,\n              type,\n              data: null\n            }\n      \n            console.log('newNode:', newNode);\n      \n            let savedNode = await this.forcePutNode(name, newNode);\n            \n            console.log('Saved Node', savedNode);\n      \n            try {\n              universe.EE.emit('nodes-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n      \n            // window.location = '/node/' + savedNode._id;\n      \n          });\n      \n        }\n        \n        @autobind\n        async handleAddMany(){\n          // Adding a whole bunch, for testing \n          \n          if(!WINDOW.confirm('Save 20 nodes?')){\n            return false;\n          }\n          \n          for(let i in universe.lodash.range(0,20)){\n            console.log('Saving new node');\n            let nodeToSave = {\n              type: 'text_note:0.0.1:local:8290j2981',\n              data: {\n                text: 'test textnote ' + (new Date()).getTime()\n              },\n              active: true,\n              createdAt: (new Date()).getTime()\n            }\n            \n            await this.forceNewNode(nodeToSave, {skipExistingLearnedNodeId:true}, true);\n            \n          }\n          \n          try {\n            universe.EE.emit('nodes-modified', '');\n          }catch(err){\n            console.error(err);\n          }\n          \n        }\n        \n        @autobind\n        makeSaveRequest(nodeToSave, opts, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            this.setState({\n              saving: true\n            })\n            \n            opts = opts || {};\n            \n            // Make request to save Node on remote \n            try {\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                          {\n                            matchActionType: 'update_node:0.0.2:local:392821982y3',\n                            dataForAction: {\n                              type: 'update_node_data:0.0.2:local:123445',\n                              data: {\n                                optionsNode: {\n                                  type: 'options_generic:0.0.1:local:289f3j29832',\n                                  data: opts || {}\n                                },\n                                dataNode: nodeToSave\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('Update response:', response);\n              \n              if(skipEvent !== true){\n                try {\n                  universe.EE.emit('nodes-modified', '');\n                }catch(err){\n                  console.error(err);\n                }\n              }\n              \n              this.setState({\n                saving: false\n              })\n              \n              return resolve({\n                type: 'node:...',\n                data: response.data.actionResponses[1]\n              });\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              alert('Failed');\n              \n              this.setState({\n                saving: false\n              })\n              \n              return reject();\n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        makeRebuildMemoryRequest(){\n          return new Promise(async (resolve, reject) => {\n            \n            try {\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                          {\n                            matchActionType: 'rebuild_memory:Qmdsf892hf98h23',\n                            dataForAction: {\n                              type: 'rebuild_memory:0.0.2:local:123445',\n                              data: {\n                                skipWaitForResolution: false\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              \n              return resolve({\n                type: 'boolean:...',\n                data: true\n              });\n              \n            } catch(err){\n              console.error('Failed rebuildMemory');\n              \n              alert('Failed rebuildMemory');\n              \n              return reject();\n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        forcePutNode(name, nodeToSave, opts, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            console.log('NewNode:', name, nodeToSave);\n            \n            // Make request to save Node on remote \n            try {\n              \n              universe.$.ajax({\n                url: '/api/put',\n                method: 'post',\n                contentType: 'application/json',\n                data: JSON.stringify({\n                  name,\n                  type: nodeToSave.type, \n                  data: nodeToSave.data\n                }),\n                success: result=>{\n                  console.log('Got result from /api/put!', result);\n                  \n                  if(skipEvent !== true){\n                    try {\n                      universe.EE.emit('nodes-modified', '');\n                    }catch(err){\n                      console.error(err);\n                    }\n                  }\n                    \n                  // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n                  let node = result;\n                  \n                  return resolve(node);\n              \n                },\n                error: errr=>{\n                  \n                  WINDOW.alert('Failed to save');\n                }\n              });\n              \n            } catch(err){\n              console.error('Failed forcePutNode', err);\n              \n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        forceNewNode(nodeToSave, opts, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            console.log('NewNode:', nodeToSave);\n                \n            // return resolve({\n            //   saveNewNode: nodeToSave\n            // });\n            \n            \n            // Make request to save Node on remote \n            try {\n              \n              // let ExternalIdentityNodes = await universe.searchMemory({\n              //   filter: {\n              //     sqlFilter: {\n              //       type: 'external_identity:0.0.1:local:8982f982j92',\n              //       data: {\n              //         commonName: 'main'\n              //       }\n              //     }\n              //   }\n              // });\n              // let ExternalIdentityNode = ExternalIdentityNodes[0];\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                          {\n                            matchActionType: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                            dataForAction: {\n                              type: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                              data: {\n                                optionsNode: {\n                                  type: 'options_generic:0.0.1:local:289f3j29832',\n                                  data: opts || {}\n                                },\n                                dataNode: nodeToSave\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('NewNode response:', response);\n              \n              // get the new node \n              let savedNode = response.data.actionResponses[1];\n              \n              // console.log('Saved Node:', savedNode);\n              \n              if(skipEvent !== true){\n                try {\n                  universe.EE.emit('nodes-modified', '');\n                }catch(err){\n                  console.error(err);\n                }\n              }\n              \n              return resolve(savedNode);\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              // alert('Failed');\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        async handleCreateInvite(){\n          \n          let inviteCode = universe.uuidv4();\n          \n          let name = WINDOW.prompt('Note for invite code?', '');\n          if(!name){\n            return false;\n          }\n          \n          let network = WINDOW.prompt('Network (public or test)', 'test');\n          if(network != 'public' && network != 'test'){\n            return false;\n          }\n          \n          inviteCode = WINDOW.prompt('Invite Code (should be unique!)', inviteCode);\n          if(!inviteCode){\n            return false;\n          }\n          \n          // TODO: \n          // - uniqueness check/constraint \n        \n          let newNode = {\n            name: universe.uuidv4(),\n            nodeId: null,\n            type: 'account_invite:Qm2934872344232324', // invite\n            data: {\n              name,\n              inviteCode,\n              network,\n              sourcePublicKey: null,\n              accepted: false,\n              uploadBytes: 0\n            }\n          }\n          \n          console.log('new invite node:', newNode);\n    \n          let savedNode = await this.forceNewNode(newNode);\n            \n          WINDOW.prompt('Invite Created!', inviteCode);\n            \n        }\n      \n        @autobind\n        handleDelete(){\n      \n          return new Promise(async (resolve,reject)=>{\n            \n            WINDOW.alert('Action not converted yet');\n            return false;\n            \n            let selectedNodes = this.props.state.selectedNodes || [];\n            \n            if(!selectedNodes.length){\n              WINDOW.alert('Select nodes using SHIFT key and clicking');\n              return false;\n            }\n      \n            // Create this new one, then iterate down the tree of kids \n            // - if this one has a nodeId, ask if we want to keep it? \n            let confirmed = WINDOW.prompt('Delete for sure?','y');\n            if(confirmed != 'y'){\n              return false;\n            }\n            \n            this.setState({\n              fetchingRemote: true\n            })\n            \n            for(let node of selectedNodes){\n                \n              // let node = JSON.parse(JSON.stringify(tmpNode));\n              console.log('Node to delete:', node);\n              node.active = false;\n              let deleted = await this.makeSaveRequest({\n                _id: node._id,\n                active: false\n              }, {\n                skipWaitForResolution: true, \n                skipRebuild: true\n              }, true);\n              \n              const deleteChildNodes = (childNodes) => {\n                return new Promise(async (resolve, reject)=>{\n                  \n                  for(let tmpNode of childNodes){\n                    console.log('ChildNode to delete:', tmpNode);\n                    // let deletedChildNode = await this.makeDelete(tmpNode);\n                    tmpNode.active = false;\n                    let deletedChildNode = await this.makeSaveRequest({\n                      _id: tmpNode._id,\n                      active: false\n                    }, {\n                      skipWaitForResolution: true, \n                      skipRebuild: true\n                    }, true);\n        \n                    if(tmpNode.nodes && tmpNode.nodes.length){\n                      await deleteChildNodes(tmpNode.nodes);\n                    }\n                  }\n                  resolve();\n        \n                });\n              }\n        \n              if(node.nodes){\n                await deleteChildNodes(node.nodes);\n              }\n            }\n      \n            console.log('rebuilding memory on remote, after bulk updates');\n            await this.makeRebuildMemoryRequest();\n            \n            this.setState({\n              fetchingRemote: false\n            });\n        \n            console.log('Done Deleting (and children)');\n          \n            try {\n              universe.EE.emit('nodes-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n            this.props.setState({\n              editingNode: null\n            })\n            \n            // Update nodes \n            this.fetchRemoteNodes();\n            \n            // window.location = '/node';\n      \n          });\n      \n        }\n        \n        @autobind\n        async handleClickNode(node, e){\n          \n          if(e.shiftKey){\n            // select multiple \n            let selectedNodes = this.props.state.selectedNodes || [];\n            let idx = selectedNodes.indexOf(node);\n            if(idx > -1){\n              selectedNodes.splice(idx,1);\n            } else {\n              selectedNodes.push(node);\n            }\n            \n            this.props.setState({\n              editingNode: null,\n              selectedNodes\n            })\n            \n            WINDOW.document.getSelection().removeAllRanges();\n            \n          } else {\n            \n            // build editingNode (without circular references) \n            \n            // fetch data from server! \n            // let nodeWithData = await this.fetchRemoteSingleNode(node._id);\n            let nodeWithData = await this.fetchRemoteSingleNodeNew(node.name);\n            console.log('nodeWithData:', nodeWithData);\n            \n            function buildNode(tmpNode){\n              \n              let tmpReturnNode = {\n                // _id: tmpNode._id,\n                // nodeId: tmpNode.nodeId,\n                // _path: tmpNode._path,\n                name: tmpNode.name,\n                type: tmpNode.type,\n                data: tmpNode.data,\n                nodes: [],\n                createdAt: tmpNode.createdAt,\n                updatedAt: tmpNode.updatedAt,\n              }\n              if(tmpNode.nodes){\n                for(let iTmpNode of tmpNode.nodes){\n                  tmpReturnNode.nodes.push(buildNode(iTmpNode));\n                }\n              }\n              return tmpReturnNode;\n            }\n            \n            let editingNode = buildNode(nodeWithData);\n            \n            this.props.setState({\n              editingNode,\n              selectedNodes: []\n            })\n          }\n        }\n        \n        @autobind\n        handleImportZip(){\n          \n          return new Promise(async (resolve,reject)=>{\n            \n            let url = WINDOW.prompt('ZIP URL (github urls parsed automatically)',''); \n            if(!url){\n              return false;\n            }\n            \n        \n            // converts startup git url into username/password \n            // - eventually allow links to be pasted, parse accordingly \n        \n            // parse github links and re-organize to fit .zip model \n        \n            this.setState({\n              saving: true\n            });\n            \n            let gh = universe.parseGitHubUrl(url);\n            if(gh.owner && \n              gh.name && \n              gh.repo && \n              gh.branch){\n              url = `https://github.com/${gh.repo}/archive/${gh.branch}.zip`;\n            }\n        \n            // cannot simply follow github zipball/tarball links :( \n            universe.fetch(`https://cors-anywhere.herokuapp.com/${url}`,{\n              // mode: 'no-cors' \n            })\n            .then(response=>{\n              // console.log('Response:', response);\n              return response.arrayBuffer();\n            })\n            .then(universe.JSZip.loadAsync)\n            .then(async (zip)=>{\n              \n              console.log('loaded zip data!', zip);\n      \n              // ZIP is valid! \n              let files = zip.files;\n      \n              function readFilePath(p){\n                return new Promise(async (resolve,reject)=>{\n                  console.log('path:', p);\n                  let r = await files[p].async('text')\n                  resolve(r);\n                });\n              }\n      \n              // load all the files \n              let allFiles = {};\n              for(let filepath of Object.keys(files)){\n                let file = files[filepath];\n                if(file.dir){\n      \n                } else {\n                  // console.log('filepath:', filepath);\n                  let contents = await readFilePath(filepath);\n                  // console.log('contents:', contents);\n                  let normalizedPath = filepath.split('/').splice(1).join('/');\n                  allFiles[normalizedPath] = contents;\n                }\n              }\n      \n              console.log('allFiles from Zip:', allFiles);\n              \n              // function addChildren(id){\n              //   return new Promise(async (resolve,reject)=>{\n            \n              //     let nodes = [];\n              //       for(let filepath of Object.keys(allFiles)){\n              //         console.log('addChildren:', filepath);\n              //         let contents = allFiles[filepath];\n              //         if(filepath.indexOf('nodes/') !== 0){\n              //           // console.log('NOT NODE:', filepath);\n              //           continue;\n              //         }\n        \n              //         let parsed = jsonParse(filepath, contents);\n              //         if(parsed.nodeId == id){\n              //           // console.log('Matches ID:', parsed.nodeId, id);\n              //           let children = await addChildren(parsed._id);\n              //           parsed.nodes = children;\n              //           nodes.push(parsed);\n              //         } else {\n              //         // console.log('No Kids:', id, parsed.nodeId);\n              //       }\n      \n              //     }\n      \n              //     resolve(nodes);\n      \n              //   });\n              // }\n              \n              function addChildren(path){\n                return new Promise(async (resolve,reject)=>{\n                \n                  let nodes = [];\n                  try {\n                      \n                    for(let filepath of Object.keys(allFiles)){\n                      let contents = allFiles[filepath];\n                      if(filepath.indexOf(path) !== 0){\n                        // console.log('NOT NODE:', filepath);\n                        continue;\n                      }\n                      let pathDepth = path.split('/').length;\n                      let filepathDepth = filepath.split('/').length;\n                      if(pathDepth == filepathDepth){\n                        // xyz.json at correct depth\n                        \n                        let parsed = jsonParse(filepath, contents);\n                        // if(parsed.nodeId == id){\n                          // console.log('Matches ID:', parsed.nodeId, id);\n                          let children = await addChildren(filepath.slice(0, filepath.length - 5) + '/'); // remove '.json'\n                          parsed.nodes = children;\n                          nodes.push(parsed);\n                        // } else {\n                        //   // console.log('No Kids:', id, parsed.nodeId);\n                        // }\n                      }\n        \n        \n                    }\n                  }catch(err){\n                    console.error(err);\n                  }\n    \n                  resolve(nodes);\n                  \n                });\n              }\n      \n              // re-organize child nodes \n              let ZipNodes;\n              try {\n                // ZipNodes = await addChildren(null); // start at root, adds children recursively\n                ZipNodes = await addChildren('nodes/'); // start at root, adds children recursively \n              }catch(err){\n                console.error('Failed zipnodes', err);\n                WINDOW.alert('Failed fetching zip nodes');\n              }\n        \n              console.log('ZipNodes:', ZipNodes);\n              \n              // let secondJson = JSON.parse(allFiles['second.json']);\n              // let basicKey = secondJson.name; \n              \n              \n              for(let node of ZipNodes){\n              \n                // iterate\n                // - save this one, then start saving down tree\n                let newNode = {\n                  name: node.name,\n                  nodeId: null, // saving to root-level!\n                  type: node.type,\n                  data: node.data,\n                }\n          \n                console.log('newNode:', newNode);\n          \n                let savedNode = await this.forceNewNode(newNode, {skipWaitForResolution: false, skipRebuild: false}, true);\n                \n                console.log('Saved Node');\n              \n                const saveChildNodes = (nodeId, childNodes) => {\n                  return new Promise(async (resolve, reject)=>{\n          \n                    console.log('Saving children');\n                    \n                    for(let tmpNode of childNodes){\n                      let newChildNode = {\n                        name: tmpNode.name,\n                        nodeId,\n                        type: tmpNode.type,\n                        data: tmpNode.data,\n                      }\n                      let savedChildNode = await this.forceNewNode(newChildNode, {skipWaitForResolution: false, skipRebuild: false}, true);\n          \n                      if(tmpNode.nodes && tmpNode.nodes.length){\n          \n                        await saveChildNodes(savedChildNode.data._id, tmpNode.nodes);\n          \n                      }\n                    }\n                    resolve();\n                  });\n                }\n          \n                await saveChildNodes(savedNode.data._id, node.nodes);\n                \n              }\n              \n              console.log('rebuilding memory on remote, after bulk updates');\n              // await this.makeRebuildMemoryRequest();\n              \n              console.log('Done Adding via Zip');\n          \n              this.setState({\n                saving: false\n              });\n              \n              try {\n                universe.EE.emit('nodes-modified', '');\n              }catch(err){\n                console.error(err);\n              }\n      \n      \n            })\n\n            \n          });\n          \n        }\n        \n        @autobind\n        handleInsertNodePaste(){\n          \n          return new Promise(async (resolve,reject)=>{\n      \n            let nodeText = this.state.pasteText; //WINDOW.prompt('Node JSON String','');\n            if(!nodeText){\n              return false;\n            }\n            \n            let node = JSON.parse(nodeText);\n            console.log('Node input:', node);\n            \n            // Create this new one, then iterate down the tree of kids \n            // - if this one has a nodeId, ask if we want to keep it? \n            let confirmed = WINDOW.prompt('Save node ('+node.type+') and children for sure?','y');\n            if(confirmed != 'y'){\n              return false;\n            }\n            \n            // iterate\n            // - save this one, then start saving down tree\n            let newNode = {\n              name: node.name || universe.uuidv4(),\n              nodeId: null, \n              type: node.type,\n              data: node.data,\n            }\n      \n            console.log('newNode:', newNode);\n      \n            let savedNode = await this.forceNewNode(newNode, {skipExistingLearnedNodeId: true});\n            \n            console.log('Saved Node');\n          \n            const saveChildNodes = (nodeId, childNodes) => {\n              return new Promise(async (resolve, reject)=>{\n      \n                console.log('Saving children');\n                \n                for(let tmpNode of childNodes){\n                  let newChildNode = {\n                    name: tmpNode.name || universe.uuidv4(),\n                    nodeId,\n                    type: tmpNode.type,\n                    data: tmpNode.data,\n                  }\n                  let savedChildNode = await this.forceNewNode(newChildNode, {skipExistingLearnedNodeId: true});\n      \n                  if(tmpNode.nodes && tmpNode.nodes.length){\n      \n                    await saveChildNodes(savedChildNode.data._id, tmpNode.nodes);\n      \n                  }\n                }\n                resolve();\n              });\n            }\n      \n            await saveChildNodes(savedNode.data._id, node.nodes);\n            \n            console.log('Done Adding via Paste');\n      \n            try {\n              universe.EE.emit('nodes-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n          });\n        }\n        \n        @autobind\n        handleNewId(){\n          let uuid = universe.uuidv4();\n          universe.copy(uuid);\n          console.log('Copied to clipboard');\n        }\n        \n        @autobind\n        renderNodes(nodes, parentInFilter, depth){\n          depth = depth || 0;\n          let filters = this.state.text.split('>');\n          // reverse filters when checking\n          filters.reverse();\n          \n          nodes = universe.lodash.sortBy(nodes, 'name');\n          // console.log('Nodes',nodes);\n          \n          return (\n            <div className=\"\">\n              {\n                nodes.map(node=>{\n                          \n                  // include this node if it, or of of it's children, matches\n                  // - highlight if a match \n                  let levelName = node.name.split('.')[depth];\n                \n                  const nodeMatchFunc = (node) => {\n                    // returns true if this node is a \"final match\" \n                    \n                    function checkNodeFilterMatch(tmpCheckNode, filter){\n                      let nodeFilterMatch;\n                      let tmpFilter;\n                      \n                      // default: path searching! \n                      // - no \":\" in search input \n                      if(filter.indexOf(':') === -1 && tmpCheckNode.name){\n                        tmpFilter = filter; //.split('p:')[1];\n                        if(tmpCheckNode.name && tmpFilter.length && pathMatch(tmpCheckNode.name, tmpFilter)){\n                          nodeFilterMatch = true;\n                        }\n                      }\n                      \n                      \n                      // all (a:)\n                      if(filter.substring(0,2) == 'a:'){\n                        tmpFilter = filter.split('a:')[1];\n                        if(tmpCheckNode._id && tmpCheckNode._id.toString().includes(tmpFilter)){\n                          nodeFilterMatch = true;\n                        }\n                        if(tmpCheckNode.type && tmpCheckNode.type.includes(tmpFilter)){\n                          nodeFilterMatch = true;\n                        }\n                        if(levelName && levelName.includes(tmpFilter)){\n                          nodeFilterMatch = true;\n                        }\n                        if(tmpCheckNode.data && JSON.stringify(tmpCheckNode.data).includes(tmpFilter)){\n                          nodeFilterMatch = true;\n                        }\n                      }\n                      // type (t:)\n                      if(filter.substring(0,2) == 't:' && tmpCheckNode.type){\n                        tmpFilter = filter.split('t:')[1];\n                        if(tmpCheckNode.type && tmpCheckNode.type.includes(tmpFilter)){\n                          nodeFilterMatch = true;\n                        }\n                      }\n                      // name (n:)\n                      if(filter.substring(0,2) == 'n:' && levelName){\n                        tmpFilter = filter.split('n:')[1];\n                        if(levelName && levelName.includes(tmpFilter)){\n                          nodeFilterMatch = true;\n                        }\n                      }\n                      // path (p:)\n                      if(filter.substring(0,2) == 'p:' && tmpCheckNode.name){\n                        tmpFilter = filter.split('p:')[1];\n                        if(tmpCheckNode.name && tmpFilter.length && pathMatch(tmpCheckNode.name, tmpFilter)){\n                          nodeFilterMatch = true;\n                        }\n                      }\n                      // data (d:) \n                      if(filter.substring(0,2) == 'd:'){\n                        tmpFilter = filter.split('d:')[1];\n                        if(tmpCheckNode.data && JSON.stringify(tmpCheckNode.data).includes(tmpFilter)){\n                          nodeFilterMatch = true;\n                        }\n                      }\n                      // sibling type (st:) \n                      if(filter.substring(0,3) == 'st:' ){\n                        tmpFilter = filter.split('st:')[1];\n                        try {\n                          let findSiblingMatch = tmpCheckNode.parent.nodes.find(n=>{\n                            if(n.type && n.type.includes(tmpFilter)){\n                              return true;\n                            }\n                          });\n                          if(findSiblingMatch){\n                            nodeFilterMatch = true;\n                          }\n                        }catch(err){\n                          // console.error(err);\n                        }\n                      }\n                      // dirtyJson (obj matcher)\n                      if(filter.substring(0,1) == '{' && filter.substring(filter.length - 1) == '}'){\n                        try {\n                          let parsedJson = universe.dirtyJSON.parse(filter);\n                          if(universe.lodash.query([tmpCheckNode.data],parsedJson).length){\n                            nodeFilterMatch = true;\n                          }\n                        }catch(err){\n                          // console.error(err);\n                        }\n                      }\n                      return nodeFilterMatch;\n                    }\n                    \n                    // iterate through filters (TODO) \n                    // - find next parent in chain that matches \n                    let filtersClone = filters.concat();\n                    let lastFilter = filtersClone.shift().trim();\n                    \n                    let filtersToPass = lastFilter.split('&');\n                    \n                    let passedAll = true;\n                    for(let ftp of filtersToPass){\n                      \n                      ftp = ftp.trim();\n                      \n                      if(checkNodeFilterMatch(node, ftp)){\n                        // matches the last check, see if parents need to be checked \n                        if(filtersClone.length){\n                          // has a parent chain to check\n                          console.log('has parent chain to check!!');\n                          // return true;\n                        } else {\n                          // no other filters, dont need to check parent chain \n                          // return true;\n                        }\n                      } else {\n                        passedAll = false;\n                      }\n                    }\n                    \n                    if(passedAll){\n                      return true;\n                    }\n                    \n                    return null;\n                    \n                  }\n                  \n                  const childMatchFunc = (nodes) => {\n                    for(let tmpNode of nodes){\n                      if(nodeMatchFunc(tmpNode)){\n                        return true;\n                      }\n                      if(childMatchFunc(tmpNode.nodes)){\n                        return true;\n                      }\n                    }\n                    return false;\n                  }\n                  \n                  let hasFilter = (filters.length && filters[0].length) ? true:false;\n                  let nodeMatch;\n                  let childMatch;\n                  if(hasFilter){\n                    \n                    nodeMatch = nodeMatchFunc(node);\n                    childMatch = childMatchFunc(node.nodes || []);\n                    \n                    // check children \n                    // - lots of recursion here, probably should memoize \n                    \n                    \n                    // // filter by \"text\" if set \n                    // nodes = nodes.filter(node=>{\n                    //   return true;\n                    // })\n                  }\n                  \n                  if(hasFilter && !nodeMatch && !childMatch && !parentInFilter){\n                    return undefined; // skip\n                  }\n                  \n                  // DO NOT SHOW CHILDREN (TODO: checkbox toggle?) \n                  if(!this.state.showChildren){\n                    if(hasFilter && parentInFilter && !childMatch && !nodeMatch){\n                      // console.log('Not showing cuz parentInFilter w/o this or child matching');\n                      return undefined;\n                    }\n                  }\n                  \n                  let tooltip = null;\n                  // return a different tooltip depending on the type\n                  let nodeTypeFirst = node.type ? node.type.split(':')[0]:null;\n                  try {\n                    switch(nodeTypeFirst){\n                      case 'react_component':\n                        tooltip = node.data.internalId;\n                        break;\n                        \n                      case 'parent_of_nodes_to_learn':\n                        tooltip = node.data.learn;\n                        break;\n                        \n                      case 'text_tag':\n                        tooltip = node.data.text;\n                        break;\n                        \n                      case 'capability':\n                        tooltip = node.data.key;\n                        break;\n                        \n                      case 'code':\n                        tooltip = node.data.note;\n                        break;\n                        \n                      case 'external_identity':\n                        tooltip = node.data.commonName || '(no commonName)';\n                        break;\n                        \n                      case 'external_identity_connect_method':\n                        tooltip = node.data.connection;\n                        break;\n                        \n                      case 'folder':\n                        tooltip = node.data.key;\n                        break;\n                        \n                      case 'node_repo_on_github':\n                        tooltip = node.data.repo;\n                        break;\n                        \n                      case 'app_base':\n                        tooltip = [node.data.name, node.data.appId].join(' - ');\n                        break;\n                        \n                      case 'platform_nodes':\n                        tooltip = node.data.platform;\n                        break;\n                        \n                      default:\n                        break;\n                    }\n                  }catch(err){\n                  }\n                  \n                  let rowStyle = {whiteSpace:'nowrap'};\n                  if(this.props.state.editingNode && this.props.state.editingNode.name == node.name){\n                    rowStyle.fontWeight = 'bold';\n                  }\n                  \n                  if(this.props.state.selectedNodes && this.props.state.selectedNodes.find(n=>{return n._id == node._id})){\n                    rowStyle.background = 'red';\n                  }\n                  \n                  return (\n                    <div key={node._id}>\n                      <div onClick={e=>this.handleClickNode(node, e)} style={{cursor:'pointer', color: nodeMatch ? 'blue':'inherit'}}>\n                    \n                          <div className=\"hover-item tooltip-holder\">\n                            <div className=\"tooltip-trigger\">\n                              <span style={rowStyle}>\n                                {levelName} <span style={{opacity:\"0.7\"}}>[{node.nodes.length}] ({node.type})</span>\n                              </span>\n                            </div>\n                            {\n                              !tooltip ? '':\n                              <div className=\"tooltip\">\n                                {tooltip}\n                              </div>\n                            }\n                          </div>\n                          \n                      </div>\n                      {\n                        !(node.nodes && node.nodes.length) ? '':\n                        <div style={{paddingLeft:'8px'}}>\n                          {this.renderNodes(node.nodes, parentInFilter || nodeMatch, depth+1)}\n                        </div>\n                      }\n                    </div>\n                  )\n                })\n              }\n            </div>\n          )\n        }\n        \n        render(){\n          \n          let nodes = this.state.nodes;\n          \n          // load actions from remote!\n          // - want to have some default actions that are easy to call/trigger \n          // - simple way of calling a Capability? \n          let actions = [];\n          \n          return (\n            <div className=\"\" style={{position:'relative'}}>\n              \n              <div style={{position:'sticky', top: '0px', borderBottom:'1px solid #ccc', background: '#eee', zIndex:'1', width:'100%'}}>\n                \n                {\n                  !this.state.pastable ? '':\n                  <div>\n                    <textarea className=\"textarea\" value={this.state.pasteText} onChange={e=>this.setState({pasteText:e.target.value})} />\n                    <button className=\"button is-primary\" onClick={this.handleInsertNodePaste}>Save</button>\n                    <button className=\"button is-pulled-right\" onClick={e=>this.setState({pastable:false})}>cancel</button>\n                  </div>\n                }\n                \n                <strong>\n                  Second Nodes (by path)\n                  \n                  &nbsp;\n                  \n                  {/*\n                  <button className={\"button is-small \" + (this.state.fetchingRemote ? 'is-loading':'')} onClick={this.fetchRemoteNodes}>\n                    <span className=\"icon is-small\">\n                      <i className=\"fas fa-sync\"></i>\n                    </span>\n                  </button>\n                  */}\n                  \n                  <button className={\"button is-small \" + (this.state.fetchingRemote ? 'is-loading':'')} onClick={this.fetchRemoteNodes}>\n                    <span className=\"icon is-small\">\n                      <i className=\"fas fa-sync\"></i>\n                    </span>\n                  </button>\n                  \n                  <div className=\"dropdown is-hoverable is-right is-pulled-right\">\n                    <div className=\"dropdown-trigger\">\n                      <button className=\"button is-small\">\n                        <span className=\"icon is-small\">\n                          <i className=\"fa fa-angle-down\"></i>\n                        </span>\n                      </button>\n                    </div>\n                    <div className=\"dropdown-menu\">\n                      <div className=\"dropdown-content\">\n                      \n                        <a className=\"dropdown-item\" onClick={this.handleNewId}>\n                          Copy New UUID to Clipboard\n                        </a>\n                        \n                        <a className=\"dropdown-item\" onClick={this.handleNewNode}>\n                          New Node (path, type)\n                        </a>\n                        \n                        {/*\n                        \n                        \n                        <a className=\"dropdown-item\" onClick={this.handleDelete}>\n                          Delete Selected\n                        </a>\n                        \n                        <a className=\"dropdown-item\" onClick={this.handleCreateInvite}>\n                          Create Invite\n                        </a>\n                        \n                        \n                        <a className=\"dropdown-item\" onClick={e=>this.setState({pastable:true})}>\n                          Insert Node By Paste\n                        </a>\n                      \n                        <a className=\"dropdown-item\" onClick={this.handleImportZip}>\n                          Import Bundle (.Zip, or GitHub) \n                        </a>\n                        \n                        <a className=\"dropdown-item\" onClick={this.handleEncryptString}>\n                          Encrypt String\n                        </a>\n                        \n                        \n                        <div className=\"dropdown-divider\"></div>\n                        \n                        <a className=\"dropdown-item\" onClick={this.handleAddMany}>\n                          Insert Many for Test\n                        </a>\n                        \n                        */}\n                        \n                      </div>\n                    </div>\n                  </div>\n                  \n                </strong>\n                \n                \n                <div className=\"field has-addons\">\n                  <div className=\"control is-expanded\">\n                    <input \n                      className=\"input\" \n                      value={this.state.text} \n                      onChange={e=>this.setState({text:e.target.value})} \n                      placeholder=\"path e.g. types.standard\" \n                    />\n                  </div>\n                  <div className=\"control\">\n                    <input \n                      type=\"checkbox\"\n                      title=\"Show Children\"\n                      className=\"checkbox\" \n                      checked={this.state.showChildren} \n                      onChange={e=>this.setState({showChildren: !this.state.showChildren})} \n                      style={{width:'40px'}}\n                    />\n                  </div>\n                </div>\n                \n              </div>\n              \n              <div style={{position:'relative'}}>\n                {this.renderNodes(nodes)}\n              </div>\n              \n            </div>\n          )\n        }\n      }\n      \n      ListComponent = universe.ReactGlobalState(ListComponent);\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: ListComponent\n      });\n      \n    }catch(err){\n      resolve({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()",
  // //   "note": "/dev left side"
  // // }
  // //   }) 
  // // await App.secondAI.MySecond.putNodeAtPath('app.second.deveditor.frontend.services.second.default_frontend.input',{
  // //   type: 'types.second.default.react_component.js',
  // //   data: {
  // // "code": "(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n  \n      console.log('---Frontend Input----');\n      console.log('INPUT:', INPUT, 'SELF:', SELF);\n      \n      // wrapped usually \n      \n      switch(INPUT.type){\n        case 'types.second.default_frontend.incoming_browser_request':\n          \n          let inputData = INPUT.data;\n          switch(inputData.type){\n            case 'types.second.frontend.browser_startup':\n              let startupReactNode = await universe.getNode('data.react_components.main');\n              console.log('startupReactNode:', startupReactNode);\n              let startupReactComponent = await universe.runInVM(startupReactNode, {});\n              console.log('startupReactComponent:', startupReactComponent);\n              return resolve(startupReactComponent);\n              \n              break;\n              \n            default:\n              console.error('Unexpected frontend input.data.type1!', INPUT);\n              break;\n          }\n        \n          break;\n          \n        default:\n          console.error('Unexpected frontend input2!', INPUT);\n          break;\n      }\n      \n    }catch(err){\n      console.error(err);\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()"
  // // }
  // // }) 
  // // await global.funcInSandboxLatest.universe.putNodeAtPath('data.second.default.routes.app',{
  // //   type: 'types.second.default.route',
  // //   data: 
  // // }) 
  // // await global.funcInSandboxLatest.universe.putNodeAtPath('data.second.default.routes.app.code',{
  // //   type: 'types.second.default.code.js',
  // //   data: 
  // // }) 




  // //   await App.secondAI.MySecond.putNodeAtPath('data.second.default.routes.app_frontend',{
  // //     type: 'types.second.default.route',
  // //     data: {
  // //   "priority": 5,
  // //   "routes": [
  // //     "/app_frontend",
  // //     "/app_frontend/*apppath",
  // //     "/app_frontend/*apppath/*any"
  // //   ]
  // // }
  // //   }) 
  // //   await App.secondAI.MySecond.putNodeAtPath('data.second.default.routes.app_frontend.code',{
  // //     type: 'types.second.default.code.js',
  // //     data: {"code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      console.log('--App route handler--', SELF.name);\n      \n      // Basically running execService with the incoming authObj \n      // - convert incoming/external authObj (with a token) to an internal authObj (with permissions) \n      \n      // expecting INPUT \n      \n      let {\n        req,\n        res \n      } = universe.requestsCache[universe.requestId];\n      \n      // console.log('INPUT for app:', INPUT);\n      let {\n        body,\n        path\n      } = req;\n      \n      // Logic: \n      // - find the possible apps we would load \n      //   - app.author.appname.* (eventually, search for \"first of type\" in a chain?) \n      // - get the input app name \n      //   - if exists, pass off the INPUT request \n      //   - if doesn't exist, show an Install page, with recommended sources for downloading the app to your Second (store, github, direct, etc)\n      //     - TODO: review the app source code easily, get a security/trust score \n      \n      console.log('PATH:', path);\n      \n      let appPath = path.split('/')[2]; // /app/appname/etc\n      \n      console.log('appath:', appPath); \n      if(appPath.indexOf('app.') !== 0){\n        // not a valid appPath \n        console.error('Not a valid appPath!:', appPath);\n        res.send('This is not a valid app path');\n        return resolve(false);\n      }\n      \n      let htmlNode;\n      \n      // require loggedin \n      // - all apps are internal-only? \n      // - TODO: per-app basis? \n      if(!req.session.loggedin){\n        // htmlNode = await universe.getNodeAtPath(universe.navPathv1(SELF.name, 1, 'login_required_html'));\n        // res.send(htmlNode ? htmlNode.data.html : 'Invalid Login Node');\n        console.log('login required, redirecting');\n        res.redirect(`/auth/login?redirect=${encodeURIComponent(req.originalUrl)}`);\n        return resolve(true);\n      }\n      \n      // - find the app name \n      let appNode = await universe.getNodeAtPath(appPath);\n      if(!appNode){\n        console.error('Missing appNode');\n        htmlNode = await universe.getNodeAtPath(universe.navPathv1(SELF.name, 1, 'install_html'));\n        res.send(htmlNode ? htmlNode.data.html : 'Invalid Install Node');\n        return false;\n      }\n      if(appNode.type != 'types.second.default.app'){\n        // invalid type of appNode \n        console.error('Invalid type of appNode ');\n        res.send('Invalid internal app specified (1)');\n        return false;\n      }\n      \n      console.log('got appNode:',appNode);\n      \n      let codeNode = appNode.nodes.find(n=>{return n.name.split('.').pop() == 'request'});\n      if(!codeNode){\n        console.error('Invalid .request codeNode for appNode ');\n        res.send('Invalid internal app specified (2)');\n        return false;\n      }\n      \n      // - of the action! (expecting/requiring it to be a Node w/ code....how to verify that? logic vs data?) \n      let appResult;\n      try {\n        // console.log('Getting appResult');\n        appResult = await universe.execCodeNode({\n          codeNode,\n          dataNode: INPUT, // passes express obj, with req, res \n        });\n      }catch(err){\n        return resolve('FAILED code from from_http, trying to run route');\n      }\n      \n      // console.log('executed route, expecting to have already responded using expressNode.data.res.send()');\n      return resolve(appResult);\n        \n    }catch(err){\n      console.error('Error:', SELF.name, err);\n      resolve({\n        type: 'types.second.default.error',\n        data: {\n          message: err.toString()\n        }\n      });\n    }\n    \n    \n  })\n})()"}
  // //   }) 
  // await App.secondAI.MySecond.putNodeAtPath('data.second.default.routes.app',{
  //   type: 'types.second.default.route',
  //   data: {
  // "routes": [
  //   "/app",
  //   "/app/*apppath",
  //   "/app/*apppath/*any"
  // ],
  // "priority": 5,
  // "auth":{
  //   "anonymous":false,
  //   "loggedin":true}
  // }
  // }) 
  // await App.secondAI.MySecond.putNodeAtPath('data.second.default.routes.app.code',{
  //   type: 'types.second.default.code.js',
  //   data: {
  // "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      console.log('--App route handler--', SELF.name);\n      \n      // Basically running execService with the incoming authObj \n      // - convert incoming/external authObj (with a token) to an internal authObj (with permissions) \n      \n      // expecting INPUT \n      \n      let {\n        req,\n        res \n      } = universe.requestsCache[universe.requestId];\n      \n      // console.log('INPUT for app:', INPUT);\n      let {\n        body,\n        path\n      } = req;\n      \n      // Logic: \n      // - find the possible apps we would load \n      //   - app.author.appname.* (eventually, search for \"first of type\" in a chain?) \n      // - get the input app name \n      //   - if exists, pass off the INPUT request \n      //   - if doesn't exist, show an Install page, with recommended sources for downloading the app to your Second (store, github, direct, etc)\n      //     - TODO: review the app source code easily, get a security/trust score \n      \n      console.log('PATH:', path);\n      \n      let appPath = path.split('/')[2]; // /app/appname/etc\n      \n      console.log('appath:', appPath); \n      if(appPath.indexOf('app.') !== 0){\n        // not a valid appPath \n        console.error('Not a valid appPath!:', appPath);\n        res.send('This is not a valid app path');\n        return resolve(false);\n      }\n      \n      let htmlNode;\n      \n      // // require loggedin \n      // // - all apps are internal-only? \n      // // - TODO: per-app basis? \n      // if(!req.session.loggedin){\n      //   // htmlNode = await universe.getNodeAtPath(universe.navPathv1(SELF.name, 1, 'login_required_html'));\n      //   // res.send(htmlNode ? htmlNode.data.html : 'Invalid Login Node');\n      //   console.log('login required, redirecting');\n      //   res.redirect(`/auth/login?redirect=${encodeURIComponent(req.originalUrl)}`);\n      //   return resolve(true);\n      // }\n      \n      // - find the app name \n      let appNode = await universe.getNodeAtPath(appPath);\n      if(!appNode){\n        console.error('Missing appNode');\n        htmlNode = await universe.getNodeAtPath(universe.navPathv1(SELF.name, 1, 'install_html'));\n        res.send(htmlNode ? htmlNode.data.html : 'Invalid Install Node');\n        return false;\n      }\n      if(appNode.type != 'types.second.default.app'){\n        // invalid type of appNode \n        console.error('Invalid type of appNode ');\n        res.send('Invalid internal app specified (1)');\n        return false;\n      }\n      \n      console.log('got appNode:',appNode);\n      \n      let codeNode = appNode.nodes.find(n=>{return n.name.split('.').pop() == 'http_request'});\n      if(!codeNode){\n        console.error('Invalid .request codeNode for appNode ');\n        res.send('Invalid internal app specified (2)');\n        return false;\n      }\n      \n      // - of the action! (expecting/requiring it to be a Node w/ code....how to verify that? logic vs data?) \n      let appResult;\n      try {\n        // console.log('Getting appResult');\n        appResult = await universe.execCodeNode({\n          codeNode,\n          dataNode: INPUT, // passes express obj, with req, res \n        });\n      }catch(err){\n        return resolve('FAILED code from from_http, trying to run route');\n      }\n      \n      // console.log('executed route, expecting to have already responded using expressNode.data.res.send()');\n      return resolve(appResult);\n        \n    }catch(err){\n      console.error('Error:', SELF.name, err);\n      resolve({\n        type: 'types.second.default.error',\n        data: {\n          message: err.toString()\n        }\n      });\n    }\n    \n    \n  })\n})()"
  // }
  // }) 
  // await App.secondAI.MySecond.putNodeAtPath('data.second.default.routes.app.install_html',{
  //   type: 'types.second.default.code.html',
  //   data: {
  // "html": "<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    <title>...</title>\n    <script src=\"https://unpkg.com/react@16/umd/react.development.js\"></script>\n    <script src=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\"></script>\n    \n    <!-- Don't use this in production: -->\n    <script src=\"https://unpkg.com/babel-standalone@6.15.0/babel.min.js\"></script>\n    \n    <style>\n      .nodisplay {\n        display: none;\n      }\n    </style>\n    \n  </head>\n  <body>\n    <div id=\"root\"></div>\n    <script type=\"text/babel\">\n      \n      class App extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {}\n        }\n        render() { \n          return (\n            <div>\n              <h1 className=\"title is-3\">Install App</h1>\n              <h3 className=\"subtitle is-5\">Sources</h3>\n            </div>\n          ); \n        } \n      }\n      \n      \n      ReactDOM.render(\n        <App />,\n        document.getElementById('root')\n      );\n\n    </script>\n    \n    \n  </body>\n</html>"
  // }
  // }) 
  // await App.secondAI.MySecond.putNodeAtPath('data.second.default.routes.app.login_required_html',{
  //   type: 'types.second.default.code.html',
  //   data: {
  // "html": "<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    <title>Second Login</title>\n    <script src=\"https://unpkg.com/react@16/umd/react.development.js\"></script>\n    <script src=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\"></script>\n    \n    <!-- Don't use this in production: -->\n    <script src=\"https://unpkg.com/babel-standalone@6.15.0/babel.min.js\"></script>\n    \n    <style>\n      .nodisplay {\n        display: none;\n      }\n    </style>\n    \n  </head>\n  <body>\n    <div id=\"root\"></div>\n    <script type=\"text/babel\">\n      \n      // require a login page (stored in session/cookie) \n      // if logged in, show the button to grant a new token \n      \n      // post login to session, reload page \n      \n      class App extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {}\n        }\n        render() { \n          return (\n            <div>\n              <h1 className=\"title is-3\">Login Required</h1>\n              <h3 className=\"subtitle is-5\">Before using apps</h3>\n              <Login />\n            </div>\n          ); \n        } \n      }\n      \n      class Login extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {\n            passphrase: ''\n          }\n        }\n        handleSubmit = async ()=>{\n          console.log('Trying login using passphrase');\n          \n          let { passphrase } = this.state;\n          \n          const rawResponse = await fetch('/auth/login', {\n            method: 'POST',\n            headers: {\n              'Accept': 'application/json',\n              'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({passphrase})\n          });\n          const content = await rawResponse.json();\n  \n          console.log('Login response:', content);\n          if(content){\n            window.location.reload();\n          } else {\n            console.log('Not logged in');\n            window.alert('Invalid passphrase');\n          }\n          \n          return false;\n        }\n        render(){\n          return (\n            <div>\n              <input \n                type=\"text\" \n                placeholder=\"passphrase\"\n                onChange={e=>this.setState({passphrase:e.target.value})}\n                value={this.state.passphrase}\n              />\n              <button onClick={this.handleSubmit}>\n                Login\n              </button>\n            </div>\n          )\n        }\n        \n      }\n      \n      \n      ReactDOM.render(\n        <App />,\n        document.getElementById('root')\n      );\n\n    </script>\n    \n    \n  </body>\n</html>"
  // }
  // }) 


  // await App.secondAI.MySecond.putNodeAtPath('app.second.deveditor',{
  //   type: 'types.second.default.app',
  //   data: {
  //     "installed_from": null,
  //     "routes": {}
  //   }
  // }) 
  // await App.secondAI.MySecond.putNodeAtPath('app.second.deveditor.http_request',{
  //   type: 'types.second.default.code.js',
  //   data: {
  // "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      console.log('--App: DevEditor--');\n      \n      // Route handling: \n      // - check for /api or /frontend \n      // - default to showing the \"app chooser\" screen \n      let {\n        req,\n        res \n      } = universe.requestsCache[universe.requestId];\n      \n      console.log('ROUTE:', req.originalUrl);\n      \n      \n      if(req.originalUrl.indexOf('/frontend') > -1){\n        console.log('Returning frontend');\n        // return frontend code (all nodes)\n        let frontendNode = await universe.getNodeAtPath( universe.navPathv1(SELF.name, 1, 'frontend') );\n        let frontendNodes = [];\n        function toArray(node){\n          node.name = node.name.substr(frontendNode.name.length + 1);\n          frontendNodes.push(node);\n          if(node.nodes){\n            for(let node2 of node.nodes){\n              toArray(node2);\n            }\n            delete node.nodes; // cleanup\n          }\n        }\n        for(let node of frontendNode.nodes){\n          toArray(node);\n        }\n        await universe.httpResponse('send', frontendNodes); //page.replace(new RegExp(\"\\\\n\", 'g'), \"\\\\n\"));\n        \n        return resolve(true);\n      }\n      \n      // Get internal Identity node (how to locate myself) \n      // - does NOT provide auth \n      \n      let privateIdentityNode;\n      let privateIdentityData = {};\n      let connectionMethodNodeData;\n      \n      try {\n        privateIdentityNode = await universe.getNodeAtPath('private.auth.owner');\n        console.log('privateIdentityNode',privateIdentityNode);\n        privateIdentityData = privateIdentityNode.data;\n        \n        let connectionMethodNode = privateIdentityNode = await universe.getNodeAtPath('private.auth.owner.connect_method');\n        connectionMethodNodeData = connectionMethodNode.data;\n        \n      }catch(err){\n        console.error('Failed private identity finding:', err);\n      }\n      // let connectionMethodNodeData = {}\n      // try {\n      //   let identityNodes = await universe.searchMemory({\n      //     cache: 'internal_private_identity',\n      //     filter: {\n      //       sqlFilter: {\n      //         // nodeId: null // OLD: root-level\n      //         type: 'identity_private:0.0.1:local:3298f2j398233',\n      //       },\n      //     }\n      //   });\n      //   privateIdentityData = identityNodes[0].data;\n      //   let connectionMethodNode = identityNodes[0].nodes.find(node=>{return node.type == 'private_identity_connect_method:0.0.1:local:9081j29h3'});\n      //   connectionMethodNodeData = connectionMethodNode.data;\n      // }catch(err){\n      //   console.error('Failed private identity finding:', err);\n      // }\n      \n      let identityNode = {  \n         \"type\":\"types.second.default.external_identity\",\n         \"data\":{  \n            \"identity\": privateIdentityData.identity,\n            \"publicKey\": privateIdentityData.public,\n         },\n         \"nodes\":[  \n            {  \n               \"type\":\"types.second.default.external_identity_connect_method\",\n               \"data\": connectionMethodNodeData,\n            }\n         ]\n      };\n      \n      console.log('identityNode:', JSON.stringify(identityNode,null,2));\n      \n      identityNode = Buffer.from(JSON.stringify(identityNode)).toString('base64');\n      \n      // // Frontend code \n      // let frontend = await universe.getNodeAtPath('private.auth.owner');\n      \n              \n      let page = `\n        <!DOCTYPE html>\n        <html>\n          <head>\n            <meta charset=\"utf-8\">\n            <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n            <title>DevEditor</title>\n              \n            <link rel=\"icon\" href=\"/favicon.ico\" type=\"image/x-icon\">\n        \n            <script src=\"https://unpkg.com/ipfs/dist/index.min.js\"></script>\n            \n            <link href=\"https://browserapp.getasecond.com/css/main.css?_=${Date.now()}\" rel=\"stylesheet\">\n            \n            <script defer src=\"https://use.fontawesome.com/releases/v5.0.13/js/all.js\" integrity=\"sha384-xymdQtn1n3lH2wcu0qhcdaOpQwyoarkgLVxC/wZ5q7h9gHtxICrpcaSUfygqZGOe\" crossorigin=\"anonymous\"></script>\n            \n          </head>\n          <body>\n            <div id=\"root\"></div>\n            <!-- Supply platform to load -->\n            <!-- Supply environment to load into platform (.zip, github link, or internal app) -->\n            <script type=\"text/javascript\">\n              window.limitedToAppName = 'Developer Editor';\n              window.useLastOfAppId = 'deveditor';\n              window.limitedToAppZip = '/app/app.second.deveditor/frontend';\n              // window.limitedToAppZip = '/appzip?appId=toolbox'; // local url \n              window.limitedToAppVersion = 1; \n              window.disallowAutoLaunchCancel = false; // should prevent the \"Startup...\" from even showing...\n              window.startupDelay = 2000;\n              window.appBaseUrl = '/app/app.second.deveditor';\n              \n              window.DEFAULT_INPUT_PATH = 'services.second.default_frontend.input';\n              \n              window.defaultExternalIdentityNode = JSON.parse(atob(\"${identityNode}\"));\n            \n            </script>\n            <script type=\"text/javascript\" src=\"https://s3-us-west-1.amazonaws.com/seconddev3-public/defaultplatform/0.1.0/main.v20.js?v=4\"></script>\n          </body>\n        </html>\n      `;\n\n      await universe.httpResponse('send', page); //page.replace(new RegExp(\"\\\\n\", 'g'), \"\\\\n\"));\n      \n      return resolve(true);\n        \n        \n    }catch(err){\n      console.error(err);\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  // }
  // }) 
  // await App.secondAI.MySecond.putNodeAtPath('app.second.blog',{
  //   type: 'types.second.default.app',
  //   data: {
  //     "installed_from": null,
  //     "routes": {
  //       "view": "view",
  //       "api": "api"
  //     }
  //   }
  // }) 
  // await App.secondAI.MySecond.putNodeAtPath('app.second.blog.http_request',{
  //   type: 'types.second.default.code.js',
  //   data: {"code":"(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      console.log('--App: --', PATH);\n      \n      // handle incoming request for an app (view, api)  \n      // - expecting express_obj \n      \n      let htmlNode, page;\n      \n      // get request session object (for finding if logged in using a cookie) \n      let {\n        req,\n        res \n      } = universe.requestsCache[universe.requestId];\n      \n      // TODO: Handle /view vs. /api requests \n      // - few standardized app endpoints: use /ai for discovery and recommendations \n      \n      htmlNode = await universe.getNodeAtPath(universe.navPathv1(SELF.name, 1, 'view_html'));\n      console.log('htmlNode:', htmlNode);\n      res.send(htmlNode.data.html);\n      \n      return resolve(true);\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"}
  // }) 
  // await App.secondAI.MySecond.putNodeAtPath('app.second.blog.view_html',{
  //   type: 'types.second.default.code.html',
  //   data: {"html":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    <title>Sample Blog App</title>\n    <script src=\"https://unpkg.com/react@16/umd/react.development.js\"></script>\n    <script src=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\"></script>\n    \n    <!-- Don't use this in production: -->\n    <script src=\"https://unpkg.com/babel-standalone@6.15.0/babel.min.js\"></script>\n    \n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/stellar-sdk/0.10.3/stellar-sdk.min.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/js-sha256/0.9.0/sha256.min.js\"></script>\n    \n    <style>\n      .nodisplay {\n        display: none;\n      }\n    </style>\n    \n  </head>\n  <body>\n    <div id=\"root\"></div>\n    <script type=\"text/babel\">\n      \n      class App extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {}\n        }\n        render() { \n          return (\n            <div>\n              <h1>Sample Blog App</h1>\n            </div>\n          ); \n        } \n      }\n      \n      \n      ReactDOM.render(\n        <App />,\n        document.getElementById('root')\n      );\n\n    </script>\n    \n    \n  </body>\n</html>"}
  // }) 

  // await App.secondAI.MySecond.putNodeAtPath('private.auth.owner',{
  //   type: 'types.second.default.auth.owner',
  //   data: {
  //     "passphrase": "test",
  //     "private": "-----BEGIN PRIVATE KEY-----\nMIIBVQIBADANBgkqhkiG9w0BAQEFAASCAT8wggE7AgEAAkEApalMWTXbMBJ5z+ML\nqr2elDxOyW7XIigkx1B4LmjwbXzRuJbHgGAZ95tTSWONcVrh0H4ZZjmIZXXOTzEh\ntKl00QIDAQABAkBqu1jlYT2HC2BQAAhUSTcSaoiYX0FcUGDhyYak4BeHcgiby7MX\n4a8We627Gy922syv2vSWetWcq96LEclZ0w3BAiEA6Hy79mfHlSv1bXvqUW62lp54\nO5007tUZdU6wQHhDsOcCIQC2amRIGezGa1o1BAi9Z5AxIhFJQnk5rRDPBEjhXAsd\nhwIgfhqKadFI9KTvbv9zzc/bwj8awFs5RwLX2EViXNXfAakCIQCRbJoL3RclTDo7\nH78z+Fc8xFMRm3v3XiCTWXAcsXtvCwIhAK0vt9SLFd9AoSVIYg9Oovw4l4Pwscjs\nR46jKAT3TEyb\n-----END PRIVATE KEY-----",
  //     "public": "-----BEGIN PUBLIC KEY-----\nMFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAKWpTFk12zASec/jC6q9npQ8Tslu1yIo\nJMdQeC5o8G180biWx4BgGfebU0ljjXFa4dB+GWY5iGV1zk8xIbSpdNECAwEAAQ==\n-----END PUBLIC KEY-----",
  //     "identity": "test://nicktest1234",
  //     "owner_seed": "SAG3BIX7VAMMKNWO5GOGQOXKISWKBZOPK3NT3ZQKOCUSWTTSHMVJ2RLR",
  //     "name": "nicktest1234",
  //     "publicUrls": {
  //       "grant": "https://second45.herokuapp.com/auth/grant",
  //       "input": "https://second45.herokuapp.com/ai"
  //     }
  //   }
  // }) 
  // await App.secondAI.MySecond.putNodeAtPath('private.auth.owner.connect_method',{
  //   type: 'types.second.default.private_identity_connect_method',
  //   data: {
  //     "method": "http",
  //     "connection": "/ai"
  //   }
  // }) 
  // await App.secondAI.MySecond.putNodeAtPath('private.login.by_secret.test',{
  //   type: 'types.second.default.auth.login_as',
  //   data: {
  //     "owner" : true
  //   }
  // }) 

}

module.exports = populate;